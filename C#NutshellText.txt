Joseph Albahari
C# 10
in a Nutshell
The Definitive Reference

C# 10 IN A
NUTSHELL
THE DEFINITIVE REFERENCE
Joseph Albahari
978-1-098-12195-2
[LSI]
C# 10 in a Nutshell
by Joseph Albahari
Copyright © 2022 Joseph Albahari. All rights reserved.
Printed in the United States of America.
Published by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.
O’Reilly books may be purchased for educational, business, or sales promotional use. Online
editions are also available for most titles (http://oreilly.com). For more information, contact
our corporate/institutional sales department: 800-998-9938 or corporate@oreilly.com.
Acquisitions Editor: Amanda Quinn
Development Editor: Corbin Collins
Production Editor: Kristen Brown
Copyeditor: Charles Roumeliotis
Proofreader: Piper Editorial Consulting, LLC
Indexer: WordCo Indexing Services, Inc.
Interior Designer: David Futato
Cover Designer: Karen Montgomery
Illustrator: Kate Dullea
February 2022: First Edition
Revision History for the First Edition
2022-02-08: First Release
See http://oreilly.com/catalog/errata.csp?isbn=9781098121952 for release details.
The O’Reilly logo is a registered trademark of O’Reilly Media, Inc. C# 10 in a Nutshell, the
cover image, and related trade dress are trademarks of O’Reilly Media, Inc.
The views expressed in this work are those of the author, and do not represent the publish‐
er’s views. While the publisher and the author have used good faith efforts to ensure that
the information and instructions contained in this work are accurate, the publisher and
the author disclaim all responsibility for errors or omissions, including without limitation
responsibility for damages resulting from the use of or reliance on this work. Use of the
information and instructions contained in this work is at your own risk. If any code samples
or other technology this work contains or describes is subject to open source licenses or the
intellectual property rights of others, it is your responsibility to ensure that your use thereof
complies with such licenses and/or rights.
Table of Contents
Preface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xi
1. Introducing C# and .NET. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
Object Orientation 1
Type Safety 2
Memory Management 3
Platform Support 3
CLRs, BCLs, and Runtimes 3
A Brief History of C# 7
2. C# Language Basics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
A First C# Program 25
Syntax 28
Type Basics 30
Numeric Types 41
Boolean Type and Operators 49
Strings and Characters 51
Arrays 54
Variables and Parameters 59
Expressions and Operators 70
Null Operators 74
Statements 76
Namespaces 87
3. Creating Types in C#. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
Classes 95
Inheritance 115
The object Type 125
Structs 129
iii
Access Modifiers 132
Interfaces 134
Enums 140
Nested Types 144
Generics 145
4. Advanced C#. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
Delegates 159
Events 167
Lambda Expressions 174
Anonymous Methods 180
try Statements and Exceptions 181
Enumeration and Iterators 189
Nullable Value Types 194
Nullable Reference Types 200
Extension Methods 202
Anonymous Types 205
Tuples 207
Records 211
Patterns 222
Attributes 227
Caller Info Attributes 229
Dynamic Binding 232
Operator Overloading 239
Unsafe Code and Pointers 243
Preprocessor Directives 249
XML Documentation 252
5. .NET Overview. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
.NET Standard 259
Runtime and C# Language Versions 261
Reference Assemblies 261
The CLR and BCL 262
Application Layers 266
6. .NET Fundamentals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
String and Text Handling 271
Dates and Times 284
DateOnly and TimeOnly 292
DateTime and Time Zones 292
iv | Table of Contents
Formatting and Parsing 297
Standard Format Strings and Parsing Flags 303
Other Conversion Mechanisms 310
Globalization 314
Working with Numbers 315
BitOperations 320
Enums 320
The Guid Struct 323
Equality Comparison 324
Order Comparison 335
Utility Classes 338
7. Collections. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343
Enumeration 343
The ICollection and IList Interfaces 351
The Array Class 355
Lists, Queues, Stacks, and Sets 363
Dictionaries 372
Customizable Collections and Proxies 378
Immutable Collections 384
Plugging in Equality and Order 388
8. LINQ Queries. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 395
Getting Started 395
Fluent Syntax 397
Query Expressions 403
Deferred Execution 408
Subqueries 414
Composition Strategies 418
Projection Strategies 421
Interpreted Queries 424
EF Core 430
Building Query Expressions 442
9. LINQ Operators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 447
Overview 448
Filtering 451
Projecting 456
Joining 468
Ordering 476
Table of Contents | v
Grouping 479
Set Operators 483
Conversion Methods 485
Element Operators 488
Aggregation Methods 490
Quantifiers 495
Generation Methods 496
10. LINQ to XML. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 497
Architectural Overview 497
X-DOM Overview 498
Instantiating an X-DOM 502
Navigating and Querying 504
Updating an X-DOM 510
Working with Values 513
Documents and Declarations 515
Names and Namespaces 519
Annotations 524
Projecting into an X-DOM 525
11. Other XML and JSON Technologies. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529
XmlReader 529
XmlWriter 537
Patterns for Using XmlReader/XmlWriter 539
Working with JSON 544
12. Disposal and Garbage Collection. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 557
IDisposable, Dispose, and Close 557
Automatic Garbage Collection 563
Finalizers 565
How the GC Works 569
Managed Memory Leaks 576
Weak References 579
13. Diagnostics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 585
Conditional Compilation 585
Debug and Trace Classes 589
Debugger Integration 592
Processes and Process Threads 593
StackTrace and StackFrame 594
vi | Table of Contents
Windows Event Logs 596
Performance Counters 598
The Stopwatch Class 602
Cross-Platform Diagnostic Tools 603
14. Concurrency and Asynchrony. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 609
Introduction 609
Threading 610
Tasks 626
Principles of Asynchrony 634
Asynchronous Functions in C# 639
Asynchronous Patterns 659
Obsolete Patterns 667
15. Streams and I/O. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 671
Stream Architecture 671
Using Streams 673
Stream Adapters 687
Compression Streams 695
Working with ZIP Files 698
File and Directory Operations 699
OS Security 710
Memory-Mapped Files 712
16. Networking. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 717
Network Architecture 717
Addresses and Ports 719
URIs 720
HttpClient 722
Writing an HTTP Server 731
Using DNS 734
Sending Mail with SmtpClient 734
Using TCP 735
Receiving POP3 Mail with TCP 739
17. Assemblies. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 741
What’s in an Assembly 741
Strong Names and Assembly Signing 746
Assembly Names 747
Authenticode Signing 749
Table of Contents | vii
Resources and Satellite Assemblies 752
Loading, Resolving, and Isolating Assemblies 759
18. Reflection and Metadata. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 781
Reflecting and Activating Types 782
Reflecting and Invoking Members 789
Reflecting Assemblies 802
Working with Attributes 803
Dynamic Code Generation 808
Emitting Assemblies and Types 815
Emitting Type Members 818
Emitting Generic Methods and Types 823
Awkward Emission Targets 825
Parsing IL 829
19. Dynamic Programming. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 835
The Dynamic Language Runtime 835
Numeric Type Unification 836
Dynamic Member Overload Resolution 838
Implementing Dynamic Objects 844
Interoperating with Dynamic Languages 847
20. Cryptography. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 851
Overview 851
Windows Data Protection 852
Hashing 853
Symmetric Encryption 855
Public-Key Encryption and Signing 860
21. Advanced Threading. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 865
Synchronization Overview 866
Exclusive Locking 866
Locking and Thread Safety 874
Nonexclusive Locking 880
Signaling with Event Wait Handles 887
The Barrier Class 894
Lazy Initialization 896
Thread-Local Storage 898
Timers 901
viii | Table of Contents
22. Parallel Programming. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 907
Why PFX? 908
PLINQ 911
The Parallel Class 924
Task Parallelism 930
Working with AggregateException 940
Concurrent Collections 942
BlockingCollection<T> 945
23. Span<T> and Memory<T>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 951
Spans and Slicing 952
Memory<T> 955
Forward-Only Enumerators 957
Working with Stack-Allocated and Unmanaged Memory 958
24. Native and COM Interoperability. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 961
Calling into Native DLLs 961
Type and Parameter Marshaling 962
Callbacks from Unmanaged Code 967
Simulating a C Union 970
Shared Memory 971
Mapping a Struct to Unmanaged Memory 973
COM Interoperability 977
Calling a COM Component from C# 979
Embedding Interop Types 982
Exposing C# Objects to COM 983
25. Regular Expressions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 987
Regular Expression Basics 987
Quantifiers 992
Zero-Width Assertions 993
Groups 996
Replacing and Splitting Text 997
Cookbook Regular Expressions 999
Regular Expressions Language Reference 1003
Index. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1007
Table of Contents | ix

Preface
C# 10 represents the ninth major update to Microsoft’s flagship programming
language, positioning C# as a language with unusual flexibility and breadth. At one
end, it offers high-level abstractions such as query expressions and asynchronous
continuations, whereas at the other end, it allows low-level efficiency through con‐
structs such as custom value types and optional pointers.
The price of this growth is that there’s more than ever to learn. Although tools such
as Microsoft’s IntelliSense—and online references—are excellent in helping you on
the job, they presume an existing map of conceptual knowledge. This book provides
exactly that map of knowledge in a concise and unified style—free of clutter and
long introductions.
Like the past seven editions, C# 10 in a Nutshell is organized around concepts and
use cases, making it friendly both to sequential reading and to random browsing.
It also plumbs significant depths while assuming only basic background knowledge,
making it accessible to intermediate as well as advanced readers.
This book covers C#, the Common Language Runtime (CLR), and the .NET 6
Base Class Library (BCL). We’ve chosen this focus to allow space for difficult
and advanced topics without compromising depth or readability. Features recently
added to C# are flagged so that you can also use this book as a reference for C# 9,
C# 8, and C# 7.
Intended Audience
This book targets intermediate to advanced audiences. No prior knowledge of
C# is required, but some general programming experience is necessary. For the
beginner, this book complements, rather than replaces, a tutorial-style introduction
to programming.
This book is an ideal companion to any of the vast array of books that focus on
an applied technology such as ASP.NET Core or Windows Presentation Foundation
xi
(WPF). C# 10 in a Nutshell covers the areas of the language and .NET that such
books omit, and vice versa.
If you’re looking for a book that skims every .NET technology, this is not for you.
This book is also unsuitable if you want to learn about APIs specific to mobile
device development.
How This Book Is Organized
Chapters 2 through 4 concentrate purely on C#, starting with the basics of syntax,
types, and variables, and finishing with advanced topics such as unsafe code and
preprocessor directives. If you’re new to the language, you should read these chap‐
ters sequentially.
The remaining chapters focus on .NET 6’s Base Class Libraries (BCLs), covering
such topics as Language-Integrated Query (LINQ), XML, collections, concurrency,
I/O and networking, memory management, reflection, dynamic programming,
attributes, cryptography, and native interoperability. You can read most of these
chapters randomly, except for Chapters 5 and 6, which lay a foundation for subse‐
quent topics. You’re also best off reading the three chapters on LINQ in sequence,
and some chapters assume some knowledge of concurrency, which we cover in
Chapter 14.
What You Need to Use This Book
The examples in this book require .NET 6. You will also find Microsoft’s .NET
documentation useful to look up individual types and members (which is available
online).
Although it’s possible to write source code in a simple text editor and build your
program from the command line, you’ll be much more productive with a code
scratchpad for instantly testing code snippets, plus an integrated development envi‐
ronment (IDE) for producing executables and libraries.
For a Windows code scratchpad, download LINQPad 7 from www.linqpad.net
(free). LINQPad fully supports C# 10 and is maintained by the author.
For a Windows IDE, download Visual Studio 2022: any edition is suitable for what’s
taught in this book. For a cross-platform IDE, download Visual Studio Code.
All code listings for all chapters are available as interactive
(editable) LINQPad samples. You can download the entire
lot in a single click: at the bottom left, click the LINQPad’s
Samples tab, click “Download more samples,” and then choose
“C# 10 in a Nutshell.”
xii | Preface
Conventions Used in This Book
The book uses basic UML notation to illustrate relationships between types, as
shown in Figure P-1. A slanted rectangle means an abstract class; a circle means
an interface. A line with a hollow triangle denotes inheritance, with the triangle
pointing to the base type. A line with an arrow denotes a one-way association; a line
without an arrow denotes a two-way association.
Figure P-1. Sample diagram
The following typographical conventions are used in this book:
Italic
Indicates new terms, URIs, filenames, and directories
Constant width
Indicates C# code, keywords and identifiers, and program output
Constant width bold
Shows a highlighted section of code
Constant width italic
Shows text that should be replaced with user-supplied values
Preface | xiii
Using Code Examples
Supplemental material (code examples, exercises, etc.) is available for download at
http://www.albahari.com/nutshell.
This book is here to help you get your job done. In general, you may use the code
in this book in your programs and documentation. You do not need to contact
us for permission unless you’re reproducing a significant portion of the code.
For example, writing a program that uses several chunks of code from this book
does not require permission. Selling or distributing examples from O’Reilly books
does require permission. Answering a question by citing this book and quoting
example code does not require permission (although we appreciate attribution).
Incorporating a significant amount of example code from this book into your
product’s documentation does require permission.
We appreciate, but generally do not require, attribution. An attribution usually
includes the title, author, publisher, and ISBN. For example: “C# 10 in a Nutshell by
Joseph Albahari (O’Reilly). Copyright 2022 Joseph Albahari, 978-1-098-12195-2.”
If you feel your use of code examples falls outside fair use or the permission given
here, feel free to contact us at permissions@oreilly.com.
O’Reilly Online Learning
For more than 40 years, O’Reilly Media has pro‐
vided technology and business training, knowl‐
edge, and insight to help companies succeed.
Our unique network of experts and innovators share their
knowledge and expertise through books, articles, and our online learning platform.
O’Reilly’s online learning platform gives you on-demand access to live training
courses, in-depth learning paths, interactive coding environments, and a vast collec‐
tion of text and video from O’Reilly and 200+ other publishers. For more informa‐
tion, visit http://oreilly.com.
How to Contact Us
Please address comments and questions concerning this book to the publisher:
O’Reilly Media, Inc.
1005 Gravenstein Highway North
Sebastopol, CA 95472
800-998-9938 (in the United States or Canada)
707-829-0515 (international or local)
707-829-0104 (fax)
We have a web page for this book, where we list errata, examples, and any additional
information. You can access this page at https://oreil.ly/c-sharp-nutshell-10.
xiv | Preface
Email bookquestions@oreilly.com to comment or ask technical questions about this
book.
For news and information about our books and courses, visit http://oreilly.com.
Find us on Facebook: http://facebook.com/oreilly
Follow us on Twitter: http://twitter.com/oreillymedia
Watch us on YouTube: http://youtube.com/oreillymedia
Acknowledgments
Since its first incarnation in 2007, this book has relied on input from some superb
technical reviewers. For their input into recent editions, I’d like to extend particular
thanks to Stephen Toub, Paulo Morgado, Fred Silberberg, Vitek Karas, Aaron Rob‐
inson, Jan Vorlicek, Sam Gentile, Rod Stephens, Jared Parsons, Matthew Groves,
Dixin Yan, Lee Coward, Bonnie DeWitt, Wonseok Chae, Lori Lalonde, and James
Montemagno.
And for their input into earlier editions, I’m most grateful to Eric Lippert, Jon Skeet,
Stephen Toub, Nicholas Paldino, Chris Burrows, Shawn Farkas, Brian Grunkemeyer,
Maoni Stephens, David DeWinter, Mike Barnett, Melitta Andersen, Mitch Wheat,
Brian Peek, Krzysztof Cwalina, Matt Warren, Joel Pobar, Glyn Griffiths, Ion Vasi‐
lian, Brad Abrams, and Adam Nathan.
I appreciate that many of the technical reviewers are accomplished individuals at
Microsoft, and I particularly thank you for taking the time to raise this book to the
next quality bar.
I want to thank Ben Albahari and Eric Johannsen, who contributed to previous
editions, and the O’Reilly team—particularly my efficient and responsive editor
Corbin Collins. Finally, my deepest thanks to my wonderful wife, Li Albahari,
whose presence kept me happy throughout the project.
Preface | xv

1
Introducing C# and .NET
C# is a general-purpose, type-safe, object-oriented programming language. The goal
of the language is programmer productivity. To this end, C# balances simplicity,
expressiveness, and performance. The chief architect of the language since its first
version is Anders Hejlsberg (creator of Turbo Pascal and architect of Delphi).
The C# language is platform neutral and works with a range of platform-specific
runtimes.
Object Orientation
C# is a rich implementation of the object-orientation paradigm, which includes
encapsulation, inheritance, and polymorphism. Encapsulation means creating a
boundary around an object to separate its external (public) behavior from its inter‐
nal (private) implementation details. Following are the distinctive features of C#
from an object-oriented perspective:
Unified type system
The fundamental building block in C# is an encapsulated unit of data and func‐
tions called a type. C# has a unified type system in which all types ultimately
share a common base type. This means that all types, whether they represent
business objects or are primitive types such as numbers, share the same basic
functionality. For example, an instance of any type can be converted to a string
by calling its ToString method.
Classes and interfaces
In a traditional object-oriented paradigm, the only kind of type is a class. In C#,
there are several other kinds of types, one of which is an interface. An interface
is like a class that cannot hold data. This means that it can define only behavior
(and not state), which allows for multiple inheritance as well as a separation
between specification and implementation.
1
Properties, methods, and events
In the pure object-oriented paradigm, all functions are methods. In C#, meth‐
ods are only one kind of function member, which also includes properties and
events (there are others, too). Properties are function members that encapsulate
a piece of an object’s state, such as a button’s color or a label’s text. Events are
function members that simplify acting on object state changes.
Although C# is primarily an object-oriented language, it also borrows from the
functional programming paradigm; specifically:
Functions can be treated as values
Using delegates, C# allows functions to be passed as values to and from other
functions.
C# supports patterns for purity
Core to functional programming is avoiding the use of variables whose values
change, in favor of declarative patterns. C# has key features to help with
those patterns, including the ability to write unnamed functions on the fly
that “capture” variables (lambda expressions) and the ability to perform list or
reactive programming via query expressions. C# also provides records, which
make it easy to write immutable (read-only) types.
Type Safety
C# is primarily a type-safe language, meaning that instances of types can interact
only through protocols they define, thereby ensuring each type’s internal consis‐
tency. For instance, C# prevents you from interacting with a string type as though it
were an integer type.
More specifically, C# supports static typing, meaning that the language enforces type
safety at compile time. This is in addition to type safety being enforced at runtime.
Static typing eliminates a large class of errors before a program is even run. It shifts
the burden away from runtime unit tests onto the compiler to verify that all the
types in a program fit together correctly. This makes large programs much easier to
manage, more predictable, and more robust. Furthermore, static typing allows tools
such as IntelliSense in Visual Studio to help you write a program because it knows
for a given variable what type it is, and hence what methods you can call on that
variable. Such tools can also identify everywhere in your program that a variable,
type, or method is used, allowing for reliable refactoring.
C# also allows parts of your code to be dynamically typed via
the dynamic keyword. However, C# remains a predominantly
statically typed language.
C# is also called a strongly typed language because its type rules are strictly enforced
(whether statically or at runtime). For instance, you cannot call a function that’s
designed to accept an integer with a floating-point number, unless you first explicitly
convert the floating-point number to an integer. This helps prevent mistakes.
2 | Chapter 1: Introducing C# and .NET
Memory Management
C# relies on the runtime to perform automatic memory management. The Com‐
mon Language Runtime has a garbage collector that executes as part of your
program, reclaiming memory for objects that are no longer referenced. This frees
programmers from explicitly deallocating the memory for an object, eliminating the
problem of incorrect pointers encountered in languages such as C++.
C# does not eliminate pointers: it merely makes them unnecessary for most pro‐
gramming tasks. For performance-critical hotspots and interoperability, pointers
and explicit memory allocation is permitted in blocks that are marked unsafe.
Platform Support
C# has runtimes that support the following platforms:
• Windows Desktop 7-11 (for rich-client, web, server, and command-line
applications)
• macOS (for rich-client, web, and command-line applications)
• Linux and macOS (for web and command-line applications)
• Android and iOS (for mobile applications)
• Windows 10 devices (Xbox, Surface Hub, and HoloLens)
There is also a technology called Blazor that can compile C# to web assembly that
runs in a browser.
CLRs, BCLs, and Runtimes
Runtime support for C# programs consists of a Common Language Runtime and
a Base Class Library. A runtime can also include a higher-level application layer
that contains libraries for developing rich-client, mobile, or web applications (see
Figure 1-1). Different runtimes exist to allow for different kinds of applications, as
well as different platforms.
Figure 1-1. Runtime architecture
Memory Management | 3
C# and .NET
Introducing
Common Language Runtime
A Common Language Runtime (CLR) provides essential runtime services such as
automatic memory management and exception handling. (The word “common”
refers to the fact that the same runtime can be shared by other managed program‐
ming languages, such as F#, Visual Basic, and Managed C++.)
C# is called a managed language because it compiles source code into managed
code, which is represented in Intermediate Language (IL). The CLR converts the
IL into the native code of the machine, such as X64 or X86, usually just prior
to execution. This is referred to as Just-in-Time (JIT) compilation. Ahead-of-time
compilation is also available to improve startup time with large assemblies or
resource-constrained devices (and to satisfy iOS app store rules when developing
mobile apps).
The container for managed code is called an assembly. An assembly contains not
only IL but also type information (metadata). The presence of metadata allows
assemblies to reference types in other assemblies without needing additional files.
You can examine and disassemble the contents of an assembly
with Microsoft’s ildasm tool. And with tools such as ILSpy or
JetBrain’s dotPeek, you can go further and decompile the IL
to C#. Because IL is higher level than native machine code,
the decompiler can do quite a good job of reconstructing the
original C#.
A program can query its own metadata (reflection) and even generate new IL at
runtime (reflection.emit).
Base Class Library
A CLR always ships with a set of assemblies called a Base Class Library (BCL).
A BCL provides core functionality to programmers, such as collections, input/out‐
put, text processing, XML/JSON handling, networking, encryption, interop, con‐
currency, and parallel programming.
A BCL also implements types that the C# language itself requires (for features such
as enumeration, querying, and asynchrony) and lets you explicitly access features of
the CLR, such as reflection and memory management.
Runtimes
A runtime (also called a framework) is a deployable unit that you download and
install. A runtime consists of a CLR (with its BCL), plus an optional application
layer specific to the kind of application that you’re writing—web, mobile, rich client,
etc. (If you’re writing a command-line console application or a non-UI library, you
don’t need an application layer.)
When writing an application, you target a particular runtime, which means that
your application uses and depends on the functionality that the runtime provides.
4 | Chapter 1: Introducing C# and .NET
Your choice of runtime also determines which platforms your application will
support.
The following table lists the major runtime options:
Application layer CLR/BCL Program type Runs on...
ASP.NET .NET 6 Web Windows, Linux, macOS
Windows Desktop .NET 6 Windows Windows 7–10+
MAUI (early 2022) .NET 6 Mobile, desktop iOS, Android, macOS, Windows 10+
WinUI 3 (early 2022) .NET 6 Win10 Windows 10+ desktop
UWP .NET Core 2.2 Win10 + Win10 devices Windows 10+ desktop & devices
(Legacy) .NET Framework .NET Framework Web, Windows Windows 7–10+
Figure 1-2 shows this information graphically and also serves as a guide to what’s
covered in the book.
Figure 1-2. Runtimes for C#
.NET 6
.NET 6 is Microsoft’s flagship open-source runtime. You can write web and console
applications that run on Windows, Linux, and macOS; rich-client applications that
run on Windows 7 through 11 and macOS; and mobile apps that run on iOS and
Android. This book focuses on the .NET 6 CLR and BCL.
CLRs, BCLs, and Runtimes | 5
C# and .NET
Introducing
Unlike .NET Framework, .NET 6 is not preinstalled on Windows machines. If you
try to run a .NET 6 application without the correct runtime being present, a mes‐
sage will appear directing you to a web page where you can download the runtime.
You can avoid this by creating a self-contained deployment, which includes the parts
of the runtime required by the application.
.NET 6’s predecessor was .NET 5, whose predecessor
was .NET Core 3. (Microsoft removed “Core” from the name
and skipped version 4.) The reason for skipping a version was
to avoid confusion with .NET Framework 4.x.
This means that assemblies compiled under .NET Core ver‐
sions 1, 2, and 3 (and .NET 5) will, in most cases, run without
modification under .NET 6. In contrast, assemblies compiled
under (any version of) .NET Framework are usually incom‐
patible with .NET 6.
The .NET 6 BCL and CLR are very similar to .NET 5 (and .NET Core 3), with their
differences centering mostly on performance and deployment.
MAUI
MAUI (Multi-platform App UI, early 2022) is designed for creating mobile apps for
iOS and Android, as well as cross-platform desktop apps for macOS and Windows.
MAUI is an evolution of Xamarin, and allows a single project to target multiple
platforms.
UWP and WinUI 3
Universal Windows Platform (UWP) is designed for writing immersive touch-first
applications that run on Windows 10+ desktop and devices (Xbox, Surface Hub,
and HoloLens). UWP apps are sandboxed and ship via the Windows Store. UWP is
preinstalled with Windows 10. It uses a version of the .NET Core 2.2 CLR/BCL, and
it’s unlikely that this dependency will be updated. Instead, Microsoft has released a
successor called WinUI 3, as part of the Windows App SDK.
The Windows App SDK works with the latest .NET, integrates better with the .NET
desktop APIs, and can run outside a sandbox. However, it does not yet support
devices such as Xbox or HoloLens.
.NET Framework
.NET Framework is Microsoft’s original Windows-only runtime for writing web
and rich-client applications that run (only) on Windows desktops/servers. No major
new releases are planned, although Microsoft will continue to support and maintain
the current 4.8 release due to the wealth of existing applications.
With the .NET Framework, the CLR/BCL is integrated with the application
layer. Applications written in .NET Framework can be recompiled under .NET 6,
although they usually require some modification. Some features of .NET Frame‐
work are not present in .NET 6 (and vice versa).
6 | Chapter 1: Introducing C# and .NET
.NET Framework is preinstalled with Windows and is automatically patched via
Windows Update. When you target .NET Framework 4.8, you can use the features
of C# 7.3 and earlier.
The word “.NET” has long been used as an umbrella term for
any technology that includes the word “.NET” (.NET Frame‐
work, .NET Core, .NET Standard, and so on).
This means that Microsoft’s renaming of .NET Core to .NET
has created an unfortunate ambiguity. In this book, we’ll refer
to the new .NET as .NET 5+. And to refer to .NET Core and
its successors, we’ll use the phrase “.NET Core and .NET 5+.”
To add to the confusion, .NET (5+) is a framework, yet it’s
very different from the .NET Framework. Hence, we’ll use the
term runtime in preference to framework, where possible.
Niche Runtimes
There are also the following niche runtimes:
• The .NET Micro Framework is for running .NET code on highly resourceconstrained embedded devices (under one megabyte).
• Unity is a game development platform that allows game logic to be scripted
with C#.
It’s also possible to run managed code within SQL Server. With SQL Server CLR
integration, you can write custom functions, stored procedures, and aggregations in
C# and then call them from SQL. This works in conjunction with .NET Framework
and a special “hosted” CLR that enforces a sandbox to protect the integrity of the
SQL Server process.
A Brief History of C#
The following is a reverse chronology of the new features in each C# version, for the
benefit of readers who are already familiar with an older version of the language.
What’s New in C# 10
C# 10 ships with Visual Studio 2022, and is used when you target .NET 6.
File-scoped namespaces
In the common case that all types in a file are defined in a single namespace,
a file-scoped namespace declaration in C# 10 reduces clutter and eliminates an
unnecessary level of indentation:
namespace MyNamespace; // Applies to everything that follows in the file.
class Class1 {} // inside MyNamespace
class Class2 {} // inside MyNamespace
A Brief History of C# | 7
C# and .NET
Introducing
The global using directive
When you prefix a using directive with the global keyword, it applies the directive
to all files in the project:
global using System;
global using System.Collection.Generic;
This lets you avoid repeating the same directives in every file. global using direc‐
tives work with using static.
Additionally, .NET 6 projects now support implicit global using directives: if the
ImplicitUsings element is set to true in the project file, the most commonly used
namespaces are automatically imported (based on the SDK project type). See “The
global using Directive (C# 10)” on page 88 for more detail.
Nondestructive mutation for anonymous types
C# 9 introduced the with keyword, to perform nondestructive mutation on records.
In C# 10, the with keyword also works with anonymous types:
var a1 = new { A = 1, B = 2, C = 3, D = 4, E = 5 };
var a2 = a1 with { E = 10 };
Console.WriteLine (a2); // { A = 1, B = 2, C = 3, D = 4, E = 10 }
New deconstruction syntax
C# 7 introduced the deconstruction syntax for tuples (or any type with a
Deconstruct method). C# 10 takes this syntax further, letting you mix assignment
and declaration in the same deconstruction:
var point = (3, 4);
double x = 0;
(x, double y) = point;
Field initializers and parameterless constructors in structs
From C# 10, you can include field initializers and parameterless constructors in
structs (see “Structs” on page 129). These execute only when the constructor is
called explicitly, and so can easily be bypassed—for instance, via the default key‐
word. This feature was introduced primarily for the benefit of struct records.
Record structs
Records were first introduced in C# 9, where they acted as a compiled-enhanced
class. In C# 10, records can also be structs:
record struct Point (int X, int Y);
The rules are otherwise similar: record structs have much the same features as class
structs (see “Records” on page 211). An exception is that the compiler-generated
properties on record structs are writable, unless you prefix the record declaration
with the readonly keyword.
8 | Chapter 1: Introducing C# and .NET
Lambda expression enhancements
The syntax around lambda expressions has been enhanced in a number of ways.
First, implicit typing (var) is permitted:
var greeter = () => "Hello, world";
The implicit type for a lambda expression is an Action or Func delegate, so greeter,
in this case, is of type Func<string>. You must explicitly state any parameter types:
var square = (int x) => x * x;
Second, a lambda expression can specify a return type:
var sqr = int (int x) => x;
This is primarily to improve compiler performance with complex nested lambdas.
Third, you can pass a lambda expression into a method parameter of type object,
Delegate, or Expression:
M1 (() => "test"); // Implicitly typed to Func<string>
M2 (() => "test"); // Implicitly typed to Func<string>
M3 (() => "test"); // Implicitly typed to Expression<Func<string>>
void M1 (object x) {}
void M2 (Delegate x) {}
void M3 (Expression x) {}
Finally, you can apply attributes to a lambda expression’s compile-generated target
method (as well as its parameters and return value):
Action a = [Description("test")] () => { };
See “Applying Attributes to Lambda Expressions (C# 10)” on page 228 for more
detail.
Nested property patterns
The following simplified syntax is legal in C# 10 for nested property pattern match‐
ing (see “Property Patterns” on page 225):
var obj = new Uri ("https://www.linqpad.net");
if (obj is Uri { Scheme.Length: 5 }) ...
This is equivalent to:
if (obj is Uri { Scheme: { Length: 5 }}) ...
CallerArgumentExpression
A method parameter to which you apply the [CallerArgumentExpression]
attribute captures an argument expression from the call site:
A Brief History of C# | 9
C# and .NET
Introducing
Print (Math.PI * 2);
void Print (double number,
 [CallerArgumentExpression("number")] string expr = null)
 => Console.WriteLine (expr);
// Output: Math.PI * 2
This feature is intended primarily for validation and assertion libraries (see “Caller‐
ArgumentExpression (C# 10)” on page 231).
Other new features
The #line directive has been enhanced in C# 10 to allow a column and range to be
specified.
Interpolated strings in C# 10 can be constants, as long as the interpolated values are
constants.
Records can seal the ToString() method in C# 10.
C#’s definite assignment analysis has been improved so that expressions such as the
following work:
if (foo?.TryParse ("123", out var number) ?? false)
 Console.WriteLine (number);
(Prior to C# 10, the compiler would generate an error: “Use of unassigned local
variable ‘number’.”)
What’s New in C# 9.0
C# 9.0 shipped with Visual Studio 2019, and is used when you target .NET 5.
Top-level statements
With top-level statements (see “Top-Level Statements” on page 35), you can write a
program without the baggage of a Main method and Program class:
using System;
Console.WriteLine ("Hello, world");
Top-level statements can include methods (which act as local methods). You can
also access command-line arguments via the “magic” args variable and return a
value to the caller. Top-level statements can be followed by type and namespace
declarations.
Init-only setters
An init-only setter (see “Init-only setters” on page 108) in a property declaration
uses the init keyword instead of the set keyword:
class Foo { public int ID { get; init; } }
10 | Chapter 1: Introducing C# and .NET
This behaves like a read-only property, except that it can also be set via an object
initializer:
var foo = new Foo { ID = 123 };
This makes it possible to create immutable (read-only) types that can be populated
via an object initializer instead of a constructor, and helps to avoid the antipattern
of constructors that accept a large number of optional parameters. Init-only setters
also allow for nondestructive mutation when used in records.
Records
A record (see “Records” on page 211) is a special kind of class that’s designed to
work well with immutable data. Its most special feature is that it supports nondes‐
tructive mutation via a new keyword (with):
Point p1 = new Point (2, 3);
Point p2 = p1 with { Y = 4 }; // p2 is a copy of p1, but with Y set to 4
Console.WriteLine (p2); // Point { X = 2, Y = 4 }
record Point
{
 public Point (double x, double y) => (X, Y) = (x, y);
 public double X { get; init; }
 public double Y { get; init; }
}
In simple cases, a record can also eliminate the boilerplate code of defining proper‐
ties and writing a constructor and deconstructor. We can replace our Point record
definition with the following, without loss of functionality:
record Point (double X, double Y);
Like tuples, records exhibit structural equality by default. Records can subclass
other records and can include the same constructs that classes can include. The
compiler implements records as classes at runtime.
Pattern-matching improvements
The relational pattern (see “Patterns” on page 222) allows the <, >, <=, and >=
operators to appear in patterns:
string GetWeightCategory (decimal bmi) => bmi switch {
 < 18.5m => "underweight",
 < 25m => "normal",
 < 30m => "overweight",
 _ => "obese" };
With pattern combinators, you can combine patterns via three new keywords (and,
or, and not):
bool IsVowel (char c) => c is 'a' or 'e' or 'i' or 'o' or 'u';
A Brief History of C# | 11
C# and .NET
Introducing
bool IsLetter (char c) => c is >= 'a' and <= 'z'
 or >= 'A' and <= 'Z';
As with the && and || operators, and has higher precedence than or. You can
override this with parentheses.
The not combinator can be used with the type pattern to test whether an object is
(not) a type:
if (obj is not string) ...
Target-typed new expressions
When constructing an object, C# 9 lets you omit the type name when the compiler
can infer it unambiguously:
System.Text.StringBuilder sb1 = new();
System.Text.StringBuilder sb2 = new ("Test");
This is particularly useful when the variable declaration and initialization are in
different parts of your code:
class Foo
{
 System.Text.StringBuilder sb;
 public Foo (string initialValue) => sb = new (initialValue);
}
And in the following scenario:
MyMethod (new ("test"));
void MyMethod (System.Text.StringBuilder sb) { ... }
see “Target-Typed new Expressions” on page 69 for more information.
Interop improvements
C# 9 introduced function pointers (see “Function Pointers” on page 248 and “Call‐
backs with Function Pointers” on page 967). Their main purpose is to allow unman‐
aged code to call static methods in C# without the overhead of a delegate instance,
with the ability to bypass the P/Invoke layer when the arguments and return types
are blittable (represented identically on each side).
C# 9 also introduced the nint and nuint native-sized integer types (see “NativeSized Integers” on page 246), which map at runtime to System.IntPtr and
System.UIntPtr. At compile time, they behave like numeric types with support
for arithmetic operations.
Other new features
Additionally, C# 9 now lets you do the following:
• Override a method or read-only property such that it returns a more derived
type (see “Covariant return types” on page 120)
12 | Chapter 1: Introducing C# and .NET
• Apply attributes to local functions (see “Attributes” on page 227)
• Apply the static keyword to lambda expressions or local functions to ensure
that you don’t accidentally capture local or instance variables (see “Static lamb‐
das” on page 177)
• Make any type work with the foreach statement, by writing a GetEnumerator
extension method
• Define a module initializer method that executes once when an assembly is
first loaded, by applying the [ModuleInitializer] attribute to a (static void
parameterless) method
• Use a “discard” (underscore symbol) as a lambda expression argument
• Write extended partial methods that are mandatory to implement—enabling
scenarios such as Roslyn’s new source generators (see “Extended partial meth‐
ods” on page 114)
• Apply an attribute to methods, types, or modules to prevent local variables
from being initialized by the runtime (see “[SkipLocalsInit]” on page 248)
What’s New in C# 8.0
C# 8.0 first shipped with Visual Studio 2019, and is still used today when you
target .NET Core 3 or .NET Standard 2.1.
Indices and ranges
Indices and ranges simplify working with elements or portions of an array (or the
low-level types Span<T> and ReadOnlySpan<T>).
Indices let you refer to elements relative to the end of an array by using the ^
operator. ^1 refers to the last element, ^2 refers to the second-to-last element, and
so on:
char[] vowels = new char[] {'a','e','i','o','u'};
char lastElement = vowels [^1]; // 'u'
char secondToLast = vowels [^2]; // 'o'
Ranges let you “slice” an array by using the .. operator:
char[] firstTwo = vowels [..2]; // 'a', 'e'
char[] lastThree = vowels [2..]; // 'i', 'o', 'u'
char[] middleOne = vowels [2..3] // 'i'
char[] lastTwo = vowels [^2..]; // 'o', 'u'
C# implements indexes and ranges with the help of the Index and Range types:
Index last = ^1;
Range firstTwoRange = 0..2;
char[] firstTwo = vowels [firstTwoRange]; // 'a', 'e'
A Brief History of C# | 13
C# and .NET
Introducing
You can support indices and ranges in your own classes by defining an indexer with
a parameter type of Index or Range:
class Sentence
{
 string[] words = "The quick brown fox".Split();
 public string this [Index index] => words [index];
 public string[] this [Range range] => words [range];
}
For more information, see “Indices” on page 56.
Null-coalescing assignment
The ??= operator assigns a variable only if it’s null. Instead of
if (s == null) s = "Hello, world";
you can now write this:
s ??= "Hello, world";
Using declarations
If you omit the brackets and statement block following a using statement, it
becomes a using declaration. The resource is then disposed when execution falls
outside the enclosing statement block:
if (File.Exists ("file.txt"))
{
 using var reader = File.OpenText ("file.txt");
 Console.WriteLine (reader.ReadLine());
 ...
}
In this case, reader will be disposed when execution falls outside the if statement
block.
Read-only members
C# 8 lets you apply the readonly modifier to a struct’s functions, ensuring that if the
function attempts to modify any field, a compile-time error is generated:
struct Point
{
 public int X, Y;
 public readonly void ResetX() => X = 0; // Error!
}
If a readonly function calls a non-readonly function, the compiler generates a
warning (and defensively copies the struct to avoid the possibility of a mutation).
14 | Chapter 1: Introducing C# and .NET
Static local methods
Adding the static modifier to a local method prevents it from seeing the local
variables and parameters of the enclosing method. This helps to reduce coupling
and enables the local method to declare variables as it pleases, without risk of
colliding with those in the containing method.
Default interface members
C# 8 lets you add a default implementation to an interface member, making it
optional to implement:
interface ILogger
{
 void Log (string text) => Console.WriteLine (text);
}
This means that you can add a member to an interface without breaking implemen‐
tations. Default implementations must be called explicitly through the interface:
((ILogger)new Logger()).Log ("message");
Interfaces can also define static members (including fields), which can be accessed
from code inside default implementations:
interface ILogger
{
 void Log (string text) => Console.WriteLine (Prefix + text);
 static string Prefix = "";
}
Or from outside the interface unless restricted via an accessibility modifier on the
static interface member (such as private, protected, or internal):
ILogger.Prefix = "File log: ";
Instance fields are prohibited. For more details, see “Default Interface Members” on
page 139.
Switch expressions
From C# 8, you can use switch in the context of an expression:
string cardName = cardNumber switch // assuming cardNumber is an int
{
 13 => "King",
 12 => "Queen",
 11 => "Jack",
 _ => "Pip card" // equivalent to 'default'
};
For more examples, see “Switch expressions” on page 82.
A Brief History of C# | 15
C# and .NET
Introducing
Tuple, positional, and property patterns
C# 8 supports three new patterns, mostly for the benefit of switch state‐
ments/expressions (see “Patterns” on page 222). Tuple patterns let you switch on
multiple values:
int cardNumber = 12; string suite = "spades";
string cardName = (cardNumber, suite) switch
{
 (13, "spades") => "King of spades",
 (13, "clubs") => "King of clubs",
 ...
};
Positional patterns allow a similar syntax for objects that expose a deconstructor,
and property patterns let you match on an object’s properties. You can use all of the
patterns both in switches and with the is operator. The following example uses a
property pattern to test whether obj is a string with a length of 4:
if (obj is string { Length:4 }) ...
Nullable reference types
Whereas nullable value types bring nullability to value types, nullable reference
types do the opposite and bring (a degree of) non-nullability to reference types,
with the purpose of helping to avoid NullReferenceExceptions. Nullable reference
types introduce a level of safety that’s enforced purely by the compiler in the
form of warnings or errors when it detects code that’s at risk of generating a
NullReferenceException.
Nullable reference types can be enabled either at the project level (via the Nullable
element in the .csproj project file) or in code (via the #nullable directive). After it’s
enabled, the compiler makes non-nullability the default: if you want a reference type
to accept nulls, you must apply the ? suffix to indicate a nullable reference type:
#nullable enable // Enable nullable reference types from this point on
string s1 = null; // Generates a compiler warning! (s1 is non-nullable)
string? s2 = null; // OK: s2 is nullable reference type
Uninitialized fields also generate a warning (if the type is not marked as nulla‐
ble), as does dereferencing a nullable reference type, if the compiler thinks a
NullReferenceException might occur:
void Foo (string? s) => Console.Write (s.Length); // Warning (.Length)
To remove the warning, you can use the null-forgiving operator (!):
void Foo (string? s) => Console.Write (s!.Length);
For a full discussion, see “Nullable Reference Types” on page 200.
16 | Chapter 1: Introducing C# and .NET
Asynchronous streams
Prior to C# 8, you could use yield return to write an iterator, or await to write
an asynchronous function. But you couldn’t do both and write an iterator that
awaits, yielding elements asynchronously. C# 8 fixes this through the introduction
of asynchronous streams:
async IAsyncEnumerable<int> RangeAsync (
 int start, int count, int delay)
{
 for (int i = start; i < start + count; i++)
 {
 await Task.Delay (delay);
 yield return i;
 }
}
The await foreach statement consumes an asynchronous stream:
await foreach (var number in RangeAsync (0, 10, 100))
 Console.WriteLine (number);
For more information, see “Asynchronous Streams” on page 650.
What’s New in C# 7.x
C# 7.x was first shipped with Visual Studio 2017. C# 7.3 is still used today by Visual
Studio 2019 when you target .NET Core 2, .NET Framework 4.6 to 4.8, or .NET
Standard 2.0.
C# 7.3
C# 7.3 made minor improvements to existing features, such as enabling use of
the equality operators with tuples, improving overload resolution, and offering the
ability to apply attributes to the backing fields of automatic properties:
[field:NonSerialized]
public int MyProperty { get; set; }
C# 7.3 also built on C# 7.2’s advanced low-allocation programming features, with
the ability to reassign ref locals, no requirement to pin when indexing fixed fields,
and field initializer support with stackalloc:
int* pointer = stackalloc int[] {1, 2, 3};
Span<int> arr = stackalloc [] {1, 2, 3};
Notice that stack-allocated memory can be assigned directly to a Span<T>. We
describe spans—and why you would use them—in Chapter 23.
C# 7.2
C# 7.2 added a new private protected modifier (the intersection of internal
and protected), the ability to follow named arguments with positional ones when
calling methods, and readonly structs. A readonly struct enforces that all fields are
A Brief History of C# | 17
C# and .NET
Introducing
readonly, to aid in declaring intent and to allow the compiler more optimization
freedom:
readonly struct Point
{
 public readonly int X, Y; // X and Y must be readonly
}
C# 7.2 also added specialized features to help with micro-optimization and lowallocation programming: see “The in modifier” on page 64, “Ref Locals” on page
67, “Ref Returns” on page 68, and “Ref Structs” on page 131).
C# 7.1
From C# 7.1, you can omit the type when using the default keyword, if the type
can be inferred:
decimal number = default; // number is decimal
C# 7.1 also relaxed the rules for switch statements (so that you can pattern-match
on generic type parameters), allowed a program’s Main method to be asynchronous,
and allowed tuple element names to be inferred:
var now = DateTime.Now;
var tuple = (now.Hour, now.Minute, now.Second);
Numeric literal improvements
Numeric literals in C# 7 can include underscores to improve readability. These are
called digit separators and are ignored by the compiler:
int million = 1_000_000;
Binary literals can be specified with the 0b prefix:
var b = 0b1010_1011_1100_1101_1110_1111;
Out variables and discards
C# 7 makes it easier to call methods that contain out parameters. First, you can now
declare out variables on the fly (see “Out variables and discards” on page 64):
bool successful = int.TryParse ("123", out int result);
Console.WriteLine (result);
And when calling a method with multiple out parameters, you can discard ones
you’re uninterested in with the underscore character:
SomeBigMethod (out _, out _, out _, out int x, out _, out _, out _);
Console.WriteLine (x);
Type patterns and pattern variables
You can also introduce variables on the fly with the is operator. These are called
pattern variables (see “Introducing a pattern variable” on page 118):
18 | Chapter 1: Introducing C# and .NET
void Foo (object x)
{
 if (x is string s)
 Console.WriteLine (s.Length);
}
The switch statement also supports type patterns, so you can switch on type as well
as constants (see “Switching on types” on page 81). You can specify conditions
with a when clause and also switch on the null value:
switch (x)
{
 case int i:
 Console.WriteLine ("It's an int!");
 break;
 case string s:
 Console.WriteLine (s.Length); // We can use the s variable
 break;
 case bool b when b == true: // Matches only when b is true
 Console.WriteLine ("True");
 break;
 case null:
 Console.WriteLine ("Nothing");
 break;
}
Local methods
A local method is a method declared within another function (see “Local methods”
on page 98):
void WriteCubes()
{
 Console.WriteLine (Cube (3));
 Console.WriteLine (Cube (4));
 Console.WriteLine (Cube (5));
 int Cube (int value) => value * value * value;
}
Local methods are visible only to the containing function and can capture local
variables in the same way that lambda expressions do.
More expression-bodied members
C# 6 introduced the expression-bodied “fat-arrow” syntax for methods, read-only
properties, operators, and indexers. C# 7 extends this to constructors, read/write
properties, and finalizers:
public class Person
{
 string name;
 public Person (string name) => Name = name;
A Brief History of C# | 19
C# and .NET
Introducing
 public string Name
 {
 get => name;
 set => name = value ?? "";
 }
 ~Person () => Console.WriteLine ("finalize");
}
Deconstructors
C# 7 introduces the deconstructor pattern (see “Deconstructors” on page 102).
Whereas a constructor typically takes a set of values (as parameters) and assigns
them to fields, a deconstructor does the reverse and assigns fields back to a set of
variables. We could write a deconstructor for the Person class in the preceding
example as follows (exception handling aside):
public void Deconstruct (out string firstName, out string lastName)
{
 int spacePos = name.IndexOf (' ');
 firstName = name.Substring (0, spacePos);
 lastName = name.Substring (spacePos + 1);
}
Deconstructors are called with the following special syntax:
var joe = new Person ("Joe Bloggs");
var (first, last) = joe; // Deconstruction
Console.WriteLine (first); // Joe
Console.WriteLine (last); // Bloggs
Tuples
Perhaps the most notable improvement to C# 7 is explicit tuple support (see
“Tuples” on page 207). Tuples provide a simple way to store a set of related values:
var bob = ("Bob", 23);
Console.WriteLine (bob.Item1); // Bob
Console.WriteLine (bob.Item2); // 23
C#’s new tuples are syntactic sugar for using the System.ValueTuple<…> generic
structs. But thanks to compiler magic, tuple elements can be named:
var tuple = (name:"Bob", age:23);
Console.WriteLine (tuple.name); // Bob
Console.WriteLine (tuple.age); // 23
With tuples, functions can return multiple values without resorting to out parame‐
ters or extra type baggage:
static (int row, int column) GetFilePosition() => (3, 10);
static void Main()
{
 var pos = GetFilePosition();
20 | Chapter 1: Introducing C# and .NET
 Console.WriteLine (pos.row); // 3
 Console.WriteLine (pos.column); // 10
}
Tuples implicitly support the deconstruction pattern, so you can easily deconstruct
them into individual variables:
static void Main()
{
 (int row, int column) = GetFilePosition(); // Creates 2 local variables
 Console.WriteLine (row); // 3
 Console.WriteLine (column); // 10
}
throw expressions
Prior to C# 7, throw was always a statement. Now it can also appear as an expression
in expression-bodied functions:
public string Foo() => throw new NotImplementedException();
A throw expression can also appear in a ternary conditional expression:
string Capitalize (string value) =>
 value == null ? throw new ArgumentException ("value") :
 value == "" ? "" :
 char.ToUpper (value[0]) + value.Substring (1);
What’s New in C# 6.0
C# 6.0, which shipped with Visual Studio 2015, features a new-generation compiler,
completely written in C#. Known as project “Roslyn,” the new compiler exposes the
entire compilation pipeline via libraries, allowing you to perform code analysis on
arbitrary source code. The compiler itself is open source, and the source code is
available at github.com/dotnet/roslyn.
In addition, C# 6.0 features several minor but significant enhancements, aimed
primarily at reducing code clutter.
The null-conditional (“Elvis”) operator (see “Null Operators” on page 74) avoids
having to explicitly check for null before calling a method or accessing a type
member. In the following example, result evaluates to null instead of throwing a
NullReferenceException:
System.Text.StringBuilder sb = null;
string result = sb?.ToString(); // result is null
Expression-bodied functions (see “Methods” on page 98) allow methods, properties,
operators, and indexers that comprise a single expression to be written more tersely,
in the style of a lambda expression:
public int TimesTwo (int x) => x * 2;
public string SomeProperty => "Property value";
A Brief History of C# | 21
C# and .NET
Introducing
Property initializers (Chapter 3) let you assign an initial value to an automatic
property:
public DateTime TimeCreated { get; set; } = DateTime.Now;
Initialized properties can also be read-only:
public DateTime TimeCreated { get; } = DateTime.Now;
Read-only properties can also be set in the constructor, making it easier to create
immutable (read-only) types.
Index initializers (Chapter 4) allow single-step initialization of any type that exposes
an indexer:
var dict = new Dictionary<int,string>()
{
 [3] = "three",
 [10] = "ten"
};
String interpolation (see “String Type” on page 52) offers a succinct alternative to
string.Format:
string s = $"It is {DateTime.Now.DayOfWeek} today";
Exception filters (see “try Statements and Exceptions” on page 181) let you apply a
condition to a catch block:
string html;
try
{
 html = await new HttpClient().GetStringAsync ("http://asef");
}
catch (WebException ex) when (ex.Status == WebExceptionStatus.Timeout)
{
 ...
}
The using static (see “Namespaces” on page 87) directive lets you import all the
static members of a type so that you can use those members unqualified:
using static System.Console;
...
WriteLine ("Hello, world"); // WriteLine instead of Console.WriteLine
The nameof (Chapter 3) operator returns the name of a variable, type, or other
symbol as a string. This avoids breaking code when you rename a symbol in Visual
Studio:
int capacity = 123;
string x = nameof (capacity); // x is "capacity"
string y = nameof (Uri.Host); // y is "Host"
And finally, you’re now allowed to await inside catch and finally blocks.
22 | Chapter 1: Introducing C# and .NET
What’s New in C# 5.0
C# 5.0’s big new feature was support for asynchronous functions via two new
keywords, async and await. Asynchronous functions enable asynchronous continu‐
ations, which make it easier to write responsive and thread-safe rich-client applica‐
tions. They also make it easy to write highly concurrent and efficient I/O-bound
applications that don’t tie up a thread resource per operation. We cover asynchro‐
nous functions in detail in Chapter 14.
What’s New in C# 4.0
C# 4.0 introduced four major enhancements:
Dynamic binding (Chapters 4 and 19) defers binding—the process of resolving types
and members—from compile time to runtime and is useful in scenarios that would
otherwise require complicated reflection code. Dynamic binding is also useful when
interoperating with dynamic languages and COM components.
Optional parameters (Chapter 2) allow functions to specify default parameter values
so that callers can omit arguments, and named arguments allow a function caller to
identify an argument by name rather than position.
Type variance rules were relaxed in C# 4.0 (Chapters 3 and 4), such that type
parameters in generic interfaces and generic delegates can be marked as covariant or
contravariant, allowing more natural type conversions.
COM interoperability (Chapter 24) was enhanced in C# 4.0 in three ways. First,
arguments can be passed by reference without the ref keyword (particularly useful
in conjunction with optional parameters). Second, assemblies that contain COM
interop types can be linked rather than referenced. Linked interop types support
type equivalence, avoiding the need for Primary Interop Assemblies and putting an
end to versioning and deployment headaches. Third, functions that return COM
Variant types from linked interop types are mapped to dynamic rather than object,
eliminating the need for casting.
What’s New in C# 3.0
The features added to C# 3.0 were mostly centered on Language-Integrated Query
(LINQ) capabilities. LINQ enables queries to be written directly within a C# pro‐
gram and checked statically for correctness, and query both local collections (such
as lists or XML documents) or remote data sources (such as a database). The C#
3.0 features added to support LINQ comprised implicitly typed local variables,
anonymous types, object initializers, lambda expressions, extension methods, query
expressions, and expression trees.
Implicitly typed local variables (var keyword, Chapter 2) let you omit the variable
type in a declaration statement, allowing the compiler to infer it. This reduces
clutter as well as allows anonymous types (Chapter 4), which are simple classes
created on the fly that are commonly used in the final output of LINQ queries. You
can also implicitly type arrays (Chapter 2).
A Brief History of C# | 23
C# and .NET
Introducing
Object initializers (Chapter 3) simplify object construction by allowing you to set
properties inline after the constructor call. Object initializers work with both named
and anonymous types.
Lambda expressions (Chapter 4) are miniature functions created by the compiler on
the fly; they are particularly useful in “fluent” LINQ queries (Chapter 8).
Extension methods (Chapter 4) extend an existing type with new methods (without
altering the type’s definition), making static methods feel like instance methods.
LINQ’s query operators are implemented as extension methods.
Query expressions (Chapter 8) provide a higher-level syntax for writing LINQ quer‐
ies that can be substantially simpler when working with multiple sequences or range
variables.
Expression trees (Chapter 8) are miniature code Document Object Models (DOMs)
that describe lambda expressions assigned to the special type Expression<TDele
gate>. Expression trees make it possible for LINQ queries to execute remotely (e.g.,
on a database server) because they can be introspected and translated at runtime
(e.g., into an SQL statement).
C# 3.0 also added automatic properties and partial methods.
Automatic properties (Chapter 3) cut the work in writing properties that simply
get/set a private backing field by having the compiler do that work automatically.
Partial methods (Chapter 3) let an autogenerated partial class provide customizable
hooks for manual authoring that “melt away” if unused.
What’s New in C# 2.0
The big new features in C# 2 were generics (Chapter 3), nullable value types (Chap‐
ter 4), iterators (Chapter 4), and anonymous methods (the predecessor to lambda
expressions). These features paved the way for the introduction of LINQ in C# 3.
C# 2 also added support for partial classes and static classes, and a host of minor
and miscellaneous features such as the namespace alias qualifier, friend assemblies,
and fixed-size buffers.
The introduction of generics required a new CLR (CLR 2.0), because generics
maintain full type fidelity at runtime.
24 | Chapter 1: Introducing C# and .NET
2
C# Language Basics
In this chapter, we introduce the basics of the C# language.
Almost all of the code listings in this book are available as
interactive samples in LINQPad. Working through these sam‐
ples in conjunction with the book accelerates learning in that
you can edit the samples and instantly see the results without
needing to set up projects and solutions in Visual Studio.
To download the samples, in LINQPad, click the Samples tab,
and then click “Download more samples.” LINQPad is free—
go to http://www.linqpad.net.
A First C# Program
Following is a program that multiplies 12 by 30 and prints the result, 360, to
the screen. The double forward slash indicates that the remainder of a line is a
comment:
int x = 12 * 30; // Statement 1
System.Console.WriteLine (x); // Statement 2
Our program consists of two statements. Statements in C# execute sequentially and
are terminated by a semicolon. The first statement computes the expression 12 * 30
and stores the result in a variable, named x, whose type is a 32-bit integer (int).
The second statement calls the WriteLine method on a class called Console, which is
defined in a namespace called System. This prints the variable x to a text window on
the screen.
A method performs a function; a class groups function members and data members
to form an object-oriented building block. The Console class groups members
that handle command-line input/output (I/O) functionality, such as the WriteLine
method. A class is a kind of type, which we examine in “Type Basics” on page 30.
25
At the outermost level, types are organized into namespaces. Many commonly used
types—including the Console class—reside in the System namespace. The .NET
libraries are organized into nested namespaces. For example, the System.Text
namespace contains types for handling text, and System.IO contain types for input/
output.
Qualifying the Console class with the System namespace on every use adds clutter.
The using directive lets you avoid this clutter by importing a namespace:
using System; // Import the System namespace
int x = 12 * 30;
Console.WriteLine (x); // No need to specify System.
A basic form of code reuse is to write higher-level functions that call lower-level
functions. We can refactor our program with a reusable method called FeetToInches
that multiplies an integer by 12, as follows:
using System;
Console.WriteLine (FeetToInches (30)); // 360
Console.WriteLine (FeetToInches (100)); // 1200
int FeetToInches (int feet)
{
 int inches = feet * 12;
 return inches;
}
Our method contains a series of statements surrounded by a pair of braces. This is
called a statement block.
A method can receive input data from the caller by specifying parameters and output
data back to the caller by specifying a return type. Our FeetToInches method has a
parameter for inputting feet, and a return type for outputting inches:
int FeetToInches (int feet)
...
The literals 30 and 100 are the arguments passed to the FeetToInches method.
If a method doesn’t receive input, use empty parentheses. If it doesn’t return any‐
thing, use the void keyword:
using System;
SayHello();
void SayHello()
{
 Console.WriteLine ("Hello, world");
}
Methods are one of several kinds of functions in C#. Another kind of function we
used in our example program was the * operator, which performs multiplication.
There are also constructors, properties, events, indexers, and finalizers.
26 | Chapter 2: C# Language Basics
Compilation
The C# compiler compiles source code (a set of files with the .cs extension) into
an assembly. An assembly is the unit of packaging and deployment in .NET. An
assembly can be either an application or a library. A normal console or Windows
application has an entry point, whereas a library does not. The purpose of a library
is to be called upon (referenced) by an application or by other libraries. .NET itself is
a set of libraries (as well as a runtime environment).
Each of the programs in the preceding section began directly with a series of state‐
ments (called top-level statements). The presence of top-level statements implicitly
creates an entry point for a console or Windows application. (Without top-level
statements, a Main method denotes an application’s entry point—see “Custom
Types” on page 31.)
Unlike .NET Framework, .NET 6 assemblies never have
an .exe extension. The .exe that you see after building a .NET 6
application is a platform-specific native loader responsible for
starting your application’s .dll assembly.
.NET 6 also allows you to create a self-contained deployment
that includes the loader, your assemblies, and the .NET run‐
time—all in a single .exe file.
The dotnet tool (dotnet.exe on Windows) helps you to manage .NET source code
and binaries from the command line. You can use it to both build and run your
program, as an alternative to using an integrated development environment (IDE)
such as Visual Studio or Visual Studio Code.
You can obtain the dotnet tool either by installing the .NET 6 SDK or by instal‐
ling Visual Studio. Its default location is %ProgramFiles%\dotnet on Windows
or /usr/bin/dotnet on Ubuntu Linux.
To compile an application, the dotnet tool requires a project file as well as one or
more C# files. The following command scaffolds a new console project (creates its
basic structure):
dotnet new Console -n MyFirstProgram
This creates a subfolder called MyFirstProgram containing a project file called
MyFirstProgram.csproj and a C# file called Program.cs that prints “Hello world”.
To build and run your program, run the following command from the MyFirstPro‐
gram folder:
dotnet run MyFirstProgram
Or, if you just want to build without running:
dotnet build MyFirstProgram.csproj
The output assembly will be written to a subdirectory under bin\debug.
We explain assemblies in detail in Chapter 17.
A First C# Program | 27
C# Language
Basics
Syntax
C# syntax is inspired by C and C++ syntax. In this section, we describe C#’s
elements of syntax, using the following program:
using System;
int x = 12 * 30;
Console.WriteLine (x);
Identifiers and Keywords
Identifiers are names that programmers choose for their classes, methods, variables,
and so on. Here are the identifiers in our example program, in the order in which
they appear:
System x Console WriteLine
An identifier must be a whole word, essentially made up of Unicode characters
starting with a letter or underscore. C# identifiers are case sensitive. By convention,
parameters, local variables, and private fields should be in camel case (e.g., myVaria
ble), and all other identifiers should be in Pascal case (e.g., MyMethod).
Keywords are names that mean something special to the compiler. There are two
keywords in our example program, using and int.
Most keywords are reserved, which means that you can’t use them as identifiers.
Here is the full list of C# reserved keywords:
abstract
as
base
bool
break
byte
case
catch
char
checked
class
const
continue
decimal
default
delegate
do
double
else
enum
event
explicit
extern
false
finally
fixed
float
for
foreach
goto
if
implicit
in
int
interface
internal
is
lock
long
namespace
new
null
object
operator
out
override
params
private
protected
public
readonly
record
ref
return
sbyte
sealed
short
sizeof
stackalloc
static
string
struct
switch
this
throw
true
try
typeof
uint
ulong
unchecked
unsafe
ushort
using
virtual
void
volatile
while
28 | Chapter 2: C# Language Basics
If you really want to use an identifier that clashes with a reserved keyword, you can
do so by qualifying it with the @ prefix; for instance:
int using = 123; // Illegal
int @using = 123; // Legal
The @ symbol doesn’t form part of the identifier itself. So, @myVariable is the same
as myVariable.
Contextual keywords
Some keywords are contextual, meaning that you also can use them as identifiers—
without an @ symbol:
add
alias
and
ascending
async
await
by
descending
dynamic
equals
from
get
global
group
init
into
join
let
managed
nameof
nint
not
notnull
nuint
on
or
orderby
partial
remove
select
set
unmanaged
value
var
with
when
where
yield
With contextual keywords, ambiguity cannot arise within the context in which they
are used.
Literals, Punctuators, and Operators
Literals are primitive pieces of data lexically embedded into the program. The
literals we used in our example program are 12 and 30.
Punctuators help demarcate the structure of the program. An example is the semi‐
colon, which terminates a statement. Statements can wrap multiple lines:
Console.WriteLine
 (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10);
An operator transforms and combines expressions. Most operators in C# are deno‐
ted with a symbol, such as the multiplication operator, *. We discuss operators in
more detail later in this chapter. These are the operators we used in our example
program:
= * . ()
A period denotes a member of something (or a decimal point with numeric literals).
Parentheses are used when declaring or calling a method; empty parentheses are
used when the method accepts no arguments. (Parentheses also have other purposes
that you’ll see later in this chapter.) An equals sign performs assignment. (The
double equals sign, ==, performs equality comparison, as you’ll see later.)
Syntax | 29
C# Language
Basics
Comments
C# offers two different styles of source-code documentation: single-line comments
and multiline comments. A single-line comment begins with a double forward slash
and continues until the end of the line; for example:
int x = 3; // Comment about assigning 3 to x
A multiline comment begins with /* and ends with */; for example:
int x = 3; /* This is a comment that
 spans two lines */
Comments can embed XML documentation tags, which we explain in “XML Docu‐
mentation” on page 252.
Type Basics
A type defines the blueprint for a value. In this example, we use two literals of type
int with values 12 and 30. We also declare a variable of type int whose name is x:
int x = 12 * 30;
Console.WriteLine (x);
Because most of the code listings in this book require types
from the System namespace, we will omit “using System”
from now on, unless we’re illustrating a concept relating to
namespaces.
A variable denotes a storage location that can contain different values over time. In
contrast, a constant always represents the same value (more on this later):
const int y = 360;
All values in C# are instances of a type. The meaning of a value and the set of
possible values a variable can have are determined by its type.
Predefined Type Examples
Predefined types are types that are specially supported by the compiler. The int
type is a predefined type for representing the set of integers that fit into 32 bits of
memory, from −231 to 231
 − 1, and is the default type for numeric literals within this
range. You can perform functions such as arithmetic with instances of the int type,
as follows:
int x = 12 * 30;
Another predefined C# type is string. The string type represents a sequence of
characters, such as “.NET” or “http://oreilly.com”. You can work with strings by
calling functions on them, as follows:
string message = "Hello world";
string upperMessage = message.ToUpper();
Console.WriteLine (upperMessage); // HELLO WORLD
30 | Chapter 2: C# Language Basics
int x = 2022;
message = message + x.ToString();
Console.WriteLine (message); // Hello world2022
In this example, we called x.ToString() to obtain a string representation of the
integer x. You can call ToString() on a variable of almost any type.
The predefined bool type has exactly two possible values: true and false. The
bool type is commonly used with an if statement to conditionally branch execution
flow:
bool simpleVar = false;
if (simpleVar)
 Console.WriteLine ("This will not print");
int x = 5000;
bool lessThanAMile = x < 5280;
if (lessThanAMile)
 Console.WriteLine ("This will print");
In C#, predefined types (also referred to as built-in types)
are recognized with a C# keyword. The System namespace
in .NET contains many important types that are not prede‐
fined by C# (e.g., DateTime).
Custom Types
Just as we can write our own methods, we can write our own types. In this next
example, we define a custom type named UnitConverter—a class that serves as a
blueprint for unit conversions:
UnitConverter feetToInchesConverter = new UnitConverter (12);
UnitConverter milesToFeetConverter = new UnitConverter (5280);
Console.WriteLine (feetToInchesConverter.Convert(30)); // 360
Console.WriteLine (feetToInchesConverter.Convert(100)); // 1200
Console.WriteLine (feetToInchesConverter.Convert(
 milesToFeetConverter.Convert(1))); // 63360
public class UnitConverter
{
 int ratio; // Field
 public UnitConverter (int unitRatio) // Constructor
 {
 ratio = unitRatio;
 }
 public int Convert (int unit) // Method
 {
 return unit * ratio;
Type Basics | 31
C# Language
Basics
 }
}
In this example, our class definition appears in the same file
as our top-level statements. This is legal—as long as the toplevel statements appear first—and is acceptable when writ‐
ing small test programs. With larger programs, the standard
approach is to put the class definition in a separate file such as
UnitConverter.cs.
Members of a type
A type contains data members and function members. The data member of
UnitConverter is the field called ratio. The function members of UnitConverter
are the Convert method and the UnitConverter’s constructor.
Symmetry of predefined types and custom types
A beautiful aspect of C# is that predefined types and custom types have few
differences. The predefined int type serves as a blueprint for integers. It holds
data—32 bits—and provides function members that use that data, such as ToString.
Similarly, our custom UnitConverter type acts as a blueprint for unit conversions. It
holds data—the ratio—and provides function members to use that data.
Constructors and instantiation
Data is created by instantiating a type. Predefined types can be instantiated simply
by using a literal such as 12 or "Hello world". The new operator creates instances of
a custom type. We created and declared an instance of the UnitConverter type with
this statement:
UnitConverter feetToInchesConverter = new UnitConverter (12);
Immediately after the new operator instantiates an object, the object’s constructor is
called to perform initialization. A constructor is defined like a method, except that
the method name and return type are reduced to the name of the enclosing type:
public UnitConverter (int unitRatio) { ratio = unitRatio; }
Instance versus static members
The data members and function members that operate on the instance of the type
are called instance members. The UnitConverter’s Convert method and the int’s
ToString method are examples of instance members. By default, members are
instance members.
Data members and function members that don’t operate on the instance of the type
can be marked as static. To refer to a static member from outside its type, you
specify its type name rather than an instance. An example is the WriteLine method
of the Console class. Because this is static, we call Console.WriteLine() and not
new Console().WriteLine().
32 | Chapter 2: C# Language Basics
(The Console class is actually declared as a static class, which means that all of its
members are static, and you can never create instances of a Console.)
In the following code, the instance field Name pertains to an instance of a particular
Panda, whereas Population pertains to the set of all Panda instances. We create two
instances of the Panda, print their names, and then print the total population:
Panda p1 = new Panda ("Pan Dee");
Panda p2 = new Panda ("Pan Dah");
Console.WriteLine (p1.Name); // Pan Dee
Console.WriteLine (p2.Name); // Pan Dah
Console.WriteLine (Panda.Population); // 2
public class Panda
{
 public string Name; // Instance field
 public static int Population; // Static field
 public Panda (string n) // Constructor
 {
 Name = n; // Assign the instance field
 Population = Population + 1; // Increment the static Population field
 }
}
Attempting to evaluate p1.Population or Panda.Name will generate a compile-time
error.
The public keyword
The public keyword exposes members to other classes. In this example, if the Name
field in Panda was not marked as public, it would be private and could not be
accessed from outside the class. Marking a member public is how a type communi‐
cates: “Here is what I want other types to see—everything else is my own private
implementation details.” In object-oriented terms, we say that the public members
encapsulate the private members of the class.
Defining namespaces
Particularly with larger programs, it makes sense to organize types into namespaces.
Here’s how to define the Panda class inside a namespace called Animals:
using System;
using Animals;
Panda p = new Panda ("Pan Dee");
Console.WriteLine (p.Name);
namespace Animals
{
 public class Panda
Type Basics | 33
C# Language
Basics
 {
 ...
 }
}
In this example, we also imported the Animals namespace so that our top-level
statements could access its types without qualification. Without that import, we’d
need to do this:
Animals.Panda p = new Animals.Panda ("Pan Dee");
We cover namespaces in detail at the end of this chapter (see “Namespaces” on page
87).
Defining a Main method
All of our examples, so far, have used top-level statements (a feature introduced in
C# 9).
Without top-level statements, a simple console or Windows application looks like
this:
using System;
class Program
{
 static void Main() // Program entry point
 {
 int x = 12 * 30;
 Console.WriteLine (x);
 }
}
In the absence of top-level statements, C# looks for a static method called Main,
which becomes the entry point. The Main method can be defined inside any class
(and only one Main method can exist). Should your Main method need to access
private members of a particular class, defining a Main method inside that class can
be simpler than using top-level statements.
The Main method can optionally return an integer (rather than void) in order
to return a value to the execution environment (where a nonzero value typically
indicates an error). The Main method can also optionally accept an array of strings
as a parameter (that will be populated with any arguments passed to the executable).
For example:
static int Main (string[] args) {...}
An array (such as string[]) represents a fixed number of
elements of a particular type. Arrays are specified by placing
square brackets after the element type. We describe them in
“Arrays” on page 54.
34 | Chapter 2: C# Language Basics
(The Main method can also be declared async and return a Task or Task<int> in
support of asynchronous programming, which we cover in Chapter 14.)
Top-Level Statements
Top-level statements (introduced in C# 9) let you avoid the baggage of a static Main
method and a containing class. A file with top-level statements comprises three
parts, in this order:
1. (Optionally) using directives
2. A series of statements, optionally mixed with method declarations
3. (Optionally) Type and namespace declarations
For example:
using System; // Part 1
Console.WriteLine ("Hello, world"); // Part 2
void SomeMethod1() { ... } // Part 2
Console.WriteLine ("Hello again!"); // Part 2
void SomeMethod2() { ... } // Part 2
class SomeClass { ... } // Part 3
namespace SomeNamespace { ... } // Part 3
Because the CLR doesn’t explicitly support top-level statements, the compiler trans‐
lates your code into something like this:
using System; // Part 1
static class Program$ // Special compiler-generated name
{
 static void Main$ (string[] args) // Compiler-generated name
 {
 Console.WriteLine ("Hello, world"); // Part 2
 void SomeMethod1() { ... } // Part 2
 Console.WriteLine ("Hello again!"); // Part 2
 void SomeMethod2() { ... } // Part 2
 }
 }
class SomeClass { ... } // Part 3
namespace SomeNamespace { ... } // Part 3
Notice that everything in Part 2 is wrapped inside the main method. This means
that SomeMethod1 and SomeMethod2 act as local methods. We discuss the full implica‐
tions in “Local methods” on page 98, the most important being that local methods
(unless declared as static) can access variables declared within the containing
method:
int x = 3;
LocalMethod();
void LocalMethod() { Console.WriteLine (x); } // We can access x
Type Basics | 35
C# Language
Basics
1 A minor caveat is that very large long values lose some precision when converted to double.
Another consequence is that top-level methods cannot be accessed from other
classes or types.
Top-level statements can optionally return an integer value to the caller and access
a “magic” variable of type string[] called args, corresponding to command-line
arguments passed by the caller.
As a program can have only one entry point, there can be at most one file with
top-level statements in a C# project.
Types and Conversions
C# can convert between instances of compatible types. A conversion always creates
a new value from an existing one. Conversions can be either implicit or explicit:
implicit conversions happen automatically, and explicit conversions require a cast.
In the following example, we implicitly convert an int to a long type (which has
twice the bit capacity of an int) and explicitly cast an int to a short type (which has
half the bit capacity of an int):
int x = 12345; // int is a 32-bit integer
long y = x; // Implicit conversion to 64-bit integer
short z = (short)x; // Explicit conversion to 16-bit integer
Implicit conversions are allowed when both of the following are true:
• The compiler can guarantee that they will always succeed.
• No information is lost in conversion.1
Conversely, explicit conversions are required when one of the following is true:
• The compiler cannot guarantee that they will always succeed.
• Information might be lost during conversion.
(If the compiler can determine that a conversion will always fail, both kinds of
conversion are prohibited. Conversions that involve generics can also fail in certain
conditions—see “Type Parameters and Conversions” on page 152.)
The numeric conversions that we just saw are built into the
language. C# also supports reference conversions and boxing
conversions (see Chapter 3) as well as custom conversions (see
“Operator Overloading” on page 239). The compiler doesn’t
enforce the aforementioned rules with custom conversions, so
it’s possible for badly designed types to behave otherwise.
36 | Chapter 2: C# Language Basics
Value Types Versus Reference Types
All C# types fall into the following categories:
• Value types
• Reference types
• Generic type parameters
• Pointer types
In this section, we describe value types and reference types.
We cover generic type parameters in “Generics” on page 145
and pointer types in “Unsafe Code and Pointers” on page 243.
Value types comprise most built-in types (specifically, all numeric types, the char
type, and the bool type) as well as custom struct and enum types.
Reference types comprise all class, array, delegate, and interface types. (This includes
the predefined string type.)
The fundamental difference between value types and reference types is how they are
handled in memory.
Value types
The content of a value type variable or constant is simply a value. For example, the
content of the built-in value type, int, is 32 bits of data.
You can define a custom value type with the struct keyword (see Figure 2-1):
public struct Point { public int X; public int Y; }
Or more tersely:
public struct Point { public int X, Y; }
Figure 2-1. A value-type instance in memory
The assignment of a value-type instance always copies the instance; for example:
Point p1 = new Point();
p1.X = 7;
Point p2 = p1; // Assignment causes copy
Console.WriteLine (p1.X); // 7
Console.WriteLine (p2.X); // 7
Type Basics | 37
C# Language
Basics
p1.X = 9; // Change p1.X
Console.WriteLine (p1.X); // 9
Console.WriteLine (p2.X); // 7
Figure 2-2 shows that p1 and p2 have independent storage.
Figure 2-2. Assignment copies a value-type instance
Reference types
A reference type is more complex than a value type, having two parts: an object and
the reference to that object. The content of a reference-type variable or constant is
a reference to an object that contains the value. Here is the Point type from our
previous example rewritten as a class rather than a struct (shown in Figure 2-3):
public class Point { public int X, Y; }
Figure 2-3. A reference-type instance in memory
Assigning a reference-type variable copies the reference, not the object instance.
This allows multiple variables to refer to the same object—something not ordinarily
possible with value types. If we repeat the previous example, but with Point now a
class, an operation to p1 affects p2:
Point p1 = new Point();
p1.X = 7;
Point p2 = p1; // Copies p1 reference
Console.WriteLine (p1.X); // 7
Console.WriteLine (p2.X); // 7
p1.X = 9; // Change p1.X
Console.WriteLine (p1.X); // 9
Console.WriteLine (p2.X); // 9
38 | Chapter 2: C# Language Basics
Figure 2-4 shows that p1 and p2 are two references that point to the same object.
Figure 2-4. Assignment copies a reference
Null
A reference can be assigned the literal null, indicating that the reference points to
no object:
Point p = null;
Console.WriteLine (p == null); // True
// The following line generates a runtime error
// (a NullReferenceException is thrown):
Console.WriteLine (p.X);
class Point {...}
In “Nullable Reference Types” on page 200, we describe a
feature of C# that helps to reduce accidental NullReference
Exception errors.
In contrast, a value type cannot ordinarily have a null value:
Point p = null; // Compile-time error
int x = null; // Compile-time error
struct Point {...}
C# also has a construct called nullable value types for repre‐
senting value-type nulls. For more information, see “Nullable
Value Types” on page 194.
Storage overhead
Value-type instances occupy precisely the memory required to store their fields. In
this example, Point takes 8 bytes of memory:
struct Point
{
 int x; // 4 bytes
 int y; // 4 bytes
}
Type Basics | 39
C# Language
Basics
Technically, the CLR positions fields within the type at an
address that’s a multiple of the fields’ size (up to a maximum
of 8 bytes). Thus, the following actually consumes 16 bytes of
memory (with the 7 bytes following the first field “wasted”):
struct A { byte b; long l; }
You can override this behavior by applying the StructLayout
attribute (see “Mapping a Struct to Unmanaged Memory” on
page 973).
Reference types require separate allocations of memory for the reference and object.
The object consumes as many bytes as its fields, plus additional administrative
overhead. The precise overhead is intrinsically private to the implementation of
the .NET runtime, but at minimum, the overhead is 8 bytes, used to store a key
to the object’s type as well as temporary information such as its lock state for
multithreading and a flag to indicate whether it has been fixed from movement by
the garbage collector. Each reference to an object requires an extra 4 or 8 bytes,
depending on whether the .NET runtime is running on a 32- or 64-bit platform.
Predefined Type Taxonomy
The predefined types in C# are as follows:
Value types
• Numeric
— Signed integer (sbyte, short, int, long)
— Unsigned integer (byte, ushort, uint, ulong)
— Real number (float, double, decimal)
• Logical (bool)
• Character (char)
Reference types
• String (string)
• Object (object)
Predefined types in C# alias .NET types in the System namespace. There is only a
syntactic difference between these two statements:
int i = 5;
System.Int32 i = 5;
The set of predefined value types excluding decimal are known as primitive types
in the CLR. Primitive types are so called because they are supported directly via
instructions in compiled code, and this usually translates to direct support on the
underlying processor; for example:
40 | Chapter 2: C# Language Basics
 // Underlying hexadecimal representation
int i = 7; // 0x7
bool b = true; // 0x1
char c = 'A'; // 0x41
float f = 0.5f; // uses IEEE floating-point encoding
The System.IntPtr and System.UIntPtr types are also primitive (see Chapter 24).
Numeric Types
C# has the predefined numeric types shown in Table 2-1.
Table 2-1. Predefined numeric types in C#
C# type System type Suffix Size Range
Integral—signed
sbyte SByte 8 bits –27
 to 27–1
short Int16 16 bits –215 to 215–1
int Int32 32 bits –231 to 231–1
long Int64 L 64 bits –263 to 263–1
nint IntPtr 32/64 bits
Integral—unsigned
byte Byte 8 bits 0 to 28–1
ushort UInt16 16 bits 0 to 216–1
uint UInt32 U 32 bits 0 to 232–1
ulong UInt64 UL 64 bits 0 to 264–1
unint UIntPtr 32/64 bits
Real
float Single F 32 bits ± (~10–45 to 1038)
double Double D 64 bits ± (~10–324 to 10308)
decimal Decimal M 128 bits ± (~10–28 to 1028)
Of the integral types, int and long are first-class citizens and are favored by both C#
and the runtime. The other integral types are typically used for interoperability or
when space efficiency is paramount. The nint and nuint native-sized integer types
(introduced in C# 9) are most useful in helping with pointer arithmetic, so we will
describe these in a later chapter (see “Native-Sized Integers” on page 246).
Numeric Types | 41
C# Language
Basics
2 Technically, decimal is a floating-point type, too, although it’s not referred to as such in the C#
language specification.
Of the real number types, float and double are called floating-point types2
and
are typically used for scientific and graphical calculations. The decimal type is
typically used for financial calculations, for which base-10-accurate arithmetic and
high precision are required.
From .NET 5, there is a 16-bit floating point type called Half.
This is intended mainly for interoperating with graphics card
processors and does not have native support in most CPUs.
Half is not a primitive CLR type and does not have special
language support in C#.
Numeric Literals
Integral-type literals can use decimal or hexadecimal notation; hexadecimal is deno‐
ted with the 0x prefix. For example:
int x = 127;
long y = 0x7F;
You can insert an underscore anywhere within a numeric literal to make it more
readable:
int million = 1_000_000;
You can specify numbers in binary with the 0b prefix:
var b = 0b1010_1011_1100_1101_1110_1111;
Real literals can use decimal and/or exponential notation:
double d = 1.5;
double million = 1E06;
Numeric literal type inference
By default, the compiler infers a numeric literal to be either double or an integral
type:
• If the literal contains a decimal point or the exponential symbol (E), it is a
double.
• Otherwise, the literal’s type is the first type in this list that can fit the literal’s
value: int, uint, long, and ulong.
For example:
Console.WriteLine ( 1.0.GetType()); // Double (double)
Console.WriteLine ( 1E06.GetType()); // Double (double)
Console.WriteLine ( 1.GetType()); // Int32 (int)
42 | Chapter 2: C# Language Basics
Console.WriteLine ( 0xF0000000.GetType()); // UInt32 (uint)
Console.WriteLine (0x100000000.GetType()); // Int64 (long)
Numeric suffixes
Numeric suffixes explicitly define the type of a literal. Suffixes can be either lower‐
case or uppercase, and are as follows:
Category C# type Example
F float float f = 1.0F;
D double double d = 1D;
M decimal decimal d = 1.0M;
U uint uint i = 1U;
L long long i = 1L;
UL ulong ulong i = 1UL;
The suffixes U and L are rarely necessary because the uint, long, and ulong types
can nearly always be either inferred or implicitly converted from int:
long i = 5; // Implicit lossless conversion from int literal to long
The D suffix is technically redundant in that all literals with a decimal point are
inferred to be double. And you can always add a decimal point to a numeric literal:
double x = 4.0;
The F and M suffixes are the most useful and should always be applied when
specifying float or decimal literals. Without the F suffix, the following line would
not compile, because 4.5 would be inferred to be of type double, which has no
implicit conversion to float:
float f = 4.5F;
The same principle is true for a decimal literal:
decimal d = -1.23M; // Will not compile without the M suffix.
We describe the semantics of numeric conversions in detail in the following section.
Numeric Conversions
Converting between integral types
Integral type conversions are implicit when the destination type can represent every
possible value of the source type. Otherwise, an explicit conversion is required; for
example:
int x = 12345; // int is a 32-bit integer
long y = x; // Implicit conversion to 64-bit integral type
short z = (short)x; // Explicit conversion to 16-bit integral type
Numeric Types | 43
C# Language
Basics
Converting between floating-point types
A float can be implicitly converted to a double given that a double can represent
every possible value of a float. The reverse conversion must be explicit.
Converting between floating-point and integral types
All integral types can be implicitly converted to all floating-point types:
int i = 1;
float f = i;
The reverse conversion must be explicit:
int i2 = (int)f;
When you cast from a floating-point number to an integral
type, any fractional portion is truncated; no rounding is per‐
formed. The static class System.Convert provides methods
that round while converting between various numeric types
(see Chapter 6).
Implicitly converting a large integral type to a floating-point type preserves magni‐
tude but can occasionally lose precision. This is because floating-point types always
have more magnitude than integral types but can have less precision. Rewriting our
example with a larger number demonstrates this:
int i1 = 100000001;
float f = i1; // Magnitude preserved, precision lost
int i2 = (int)f; // 100000000
Decimal conversions
All integral types can be implicitly converted to the decimal type given that a
decimal can represent every possible C# integral-type value. All other numeric
conversions to and from a decimal type must be explicit because they introduce the
possibility of either a value being out of range or precision being lost.
Arithmetic Operators
The arithmetic operators (+, -, *, /, %) are defined for all numeric types except the 8-
and 16-bit integral types:
+ Addition
- Subtraction
* Multiplication
/ Division
% Remainder after division
44 | Chapter 2: C# Language Basics
Increment and Decrement Operators
The increment and decrement operators (++, --, respectively) increment and decre‐
ment numeric types by 1. The operator can either follow or precede the variable,
depending on whether you want its value before or after the increment/decrement;
for example:
int x = 0, y = 0;
Console.WriteLine (x++); // Outputs 0; x is now 1
Console.WriteLine (++y); // Outputs 1; y is now 1
Specialized Operations on Integral Types
The integral types are int, uint, long, ulong, short, ushort, byte, and sbyte.
Division
Division operations on integral types always eliminate the remainder (round toward
zero). Dividing by a variable whose value is zero generates a runtime error (a
DivideByZeroException):
int a = 2 / 3; // 0
int b = 0;
int c = 5 / b; // throws DivideByZeroException
Dividing by the literal or constant 0 generates a compile-time error.
Overflow
At runtime, arithmetic operations on integral types can overflow. By default, this
happens silently—no exception is thrown, and the result exhibits “wraparound”
behavior, as though the computation were done on a larger integer type and the
extra significant bits discarded. For example, decrementing the minimum possible
int value results in the maximum possible int value:
int a = int.MinValue;
a--;
Console.WriteLine (a == int.MaxValue); // True
Overflow check operators
The checked operator instructs the runtime to generate an OverflowException
rather than overflowing silently when an integral-type expression or statement
exceeds the arithmetic limits of that type. The checked operator affects expressions
with the ++, −−, +, − (binary and unary), *, /, and explicit conversion operators
between integral types. Overflow checking incurs a small performance cost.
The checked operator has no effect on the double and float
types (which overflow to special “infinite” values, as you’ll see
soon) and no effect on the decimal type (which is always
checked).
Numeric Types | 45
C# Language
Basics
You can use checked around either an expression or a statement block:
int a = 1000000;
int b = 1000000;
int c = checked (a * b); // Checks just the expression.
checked // Checks all expressions
{ // in statement block.
 ...
 c = a * b;
 ...
}
You can make arithmetic overflow checking the default for all expressions in a
program by selecting the “checked” option at the project level (in Visual Studio,
go to Advanced Build Settings). If you then need to disable overflow checking just
for specific expressions or statements, you can do so with the unchecked operator.
For example, the following code will not throw exceptions—even if the project’s
“checked” option is selected:
int x = int.MaxValue;
int y = unchecked (x + 1);
unchecked { int z = x + 1; }
Overflow checking for constant expressions
Regardless of the “checked” project setting, expressions evaluated at compile time
are always overflow-checked—unless you apply the unchecked operator:
int x = int.MaxValue + 1; // Compile-time error
int y = unchecked (int.MaxValue + 1); // No errors
Bitwise operators
C# supports the following bitwise operators:
Operator Meaning Sample expression Result
~ Complement ~0xfU 0xfffffff0U
& And 0xf0 & 0x33 0x30
| Or 0xf0 | 0x33 0xf3
^ Exclusive Or 0xff00 ^ 0x0ff0 0xf0f0
<< Shift left 0x20 << 2 0x80
>> Shift right 0x20 >> 1 0x10
From .NET 6, additional bitwise operations are exposed via
a new class called BitOperations in the System.Numerics
namespace (see “BitOperations” on page 320).
46 | Chapter 2: C# Language Basics
8- and 16-Bit Integral Types
The 8- and 16-bit integral types are byte, sbyte, short, and ushort. These types
lack their own arithmetic operators, so C# implicitly converts them to larger types
as required. This can cause a compile-time error when trying to assign the result
back to a small integral type:
short x = 1, y = 1;
short z = x + y; // Compile-time error
In this case, x and y are implicitly converted to int so that the addition can be
performed. This means that the result is also an int, which cannot be implicitly cast
back to a short (because it could cause loss of data). To make this compile, you
must add an explicit cast:
short z = (short) (x + y); // OK
Special Float and Double Values
Unlike integral types, floating-point types have values that certain operations treat
specially. These special values are NaN (Not a Number), +∞, −∞, and −0. The float
and double classes have constants for NaN, +∞, and −∞, as well as other values
(MaxValue, MinValue, and Epsilon); for example:
Console.WriteLine (double.NegativeInfinity); // -Infinity
The constants that represent special values for double and float are as follows:
Special value Double constant Float constant
NaN double.NaN float.NaN
+∞ double.PositiveInfinity float.PositiveInfinity
−∞ double.NegativeInfinity float.NegativeInfinity
−0 −0.0 −0.0f
Dividing a nonzero number by zero results in an infinite value:
Console.WriteLine ( 1.0 / 0.0); // Infinity
Console.WriteLine (−1.0 / 0.0); // -Infinity
Console.WriteLine ( 1.0 / −0.0); // -Infinity
Console.WriteLine (−1.0 / −0.0); // Infinity
Dividing zero by zero, or subtracting infinity from infinity, results in a NaN:
Console.WriteLine ( 0.0 / 0.0); // NaN
Console.WriteLine ((1.0 / 0.0) − (1.0 / 0.0)); // NaN
When using ==, a NaN value is never equal to another value, even another NaN
value:
Console.WriteLine (0.0 / 0.0 == double.NaN); // False
Numeric Types | 47
C# Language
Basics
To test whether a value is NaN, you must use the float.IsNaN or double.IsNaN
method:
Console.WriteLine (double.IsNaN (0.0 / 0.0)); // True
When using object.Equals, however, two NaN values are equal:
Console.WriteLine (object.Equals (0.0 / 0.0, double.NaN)); // True
NaNs are sometimes useful in representing special values. In
Windows Presentation Foundation (WPF), double.NaN repre‐
sents a measurement whose value is “Automatic.” Another way
to represent such a value is with a nullable type (Chapter 4);
another is with a custom struct that wraps a numeric type and
adds an additional field (Chapter 3).
float and double follow the specification of the IEEE 754 format types, supported
natively by almost all processors. You can find detailed information on the behavior
of these types at http://www.ieee.org.
double Versus decimal
double is useful for scientific computations (such as computing spatial coordinates).
decimal is useful for financial computations and values that are “human-made”
rather than the result of real-world measurements. Here’s a summary of the
differences:
Category double decimal
Internal representation Base 2 Base 10
Decimal precision 15–16 significant figures 28–29 significant figures
Range ±(~10−324 to ~10308) ±(~10−28 to ~1028)
Special values +0, −0, +∞, −∞, and NaN None
Speed Native to processor Non-native to processor (about 10 times slower
than double)
Real Number Rounding Errors
float and double internally represent numbers in base 2. For this reason, only
numbers expressible in base 2 are represented precisely. Practically, this means most
literals with a fractional component (which are in base 10) will not be represented
precisely; for example:
float x = 0.1f; // Not quite 0.1
Console.WriteLine (x + x + x + x + x + x + x + x + x + x); // 1.0000001
This is why float and double are bad for financial calculations. In contrast,
decimal works in base 10 and so can precisely represent numbers expressible in
base 10 (as well as its factors, base 2 and base 5). Because real literals are in base 10,
decimal can precisely represent numbers such as 0.1. However, neither double nor
48 | Chapter 2: C# Language Basics
3 It’s possible to overload these operators (Chapter 4) such that they return a non-bool type, but
this is almost never done in practice.
decimal can precisely represent a fractional number whose base 10 representation is
recurring:
decimal m = 1M / 6M; // 0.1666666666666666666666666667M
double d = 1.0 / 6.0; // 0.16666666666666666
This leads to accumulated rounding errors:
decimal notQuiteWholeM = m+m+m+m+m+m; // 1.0000000000000000000000000002M
double notQuiteWholeD = d+d+d+d+d+d; // 0.99999999999999989
which break equality and comparison operations:
Console.WriteLine (notQuiteWholeM == 1M); // False
Console.WriteLine (notQuiteWholeD < 1.0); // True
Boolean Type and Operators
C#’s bool type (aliasing the System.Boolean type) is a logical value that can be
assigned the literal true or false.
Although a Boolean value requires only one bit of storage, the runtime will use one
byte of memory because this is the minimum chunk that the runtime and processor
can efficiently work with. To avoid space inefficiency in the case of arrays, .NET
provides a BitArray class in the System.Collections namespace that is designed to
use just one bit per Boolean value.
bool Conversions
No casting conversions can be made from the bool type to numeric types, or
vice versa.
Equality and Comparison Operators
== and != test for equality and inequality of any type but always return a bool
value.3
 Value types typically have a very simple notion of equality:
int x = 1;
int y = 2;
int z = 1;
Console.WriteLine (x == y); // False
Console.WriteLine (x == z); // True
For reference types, equality, by default, is based on reference, as opposed to the
actual value of the underlying object (more on this in Chapter 6):
Dude d1 = new Dude ("John");
Dude d2 = new Dude ("John");
Console.WriteLine (d1 == d2); // False
Dude d3 = d1;
Boolean Type and Operators | 49
C# Language
Basics
Console.WriteLine (d1 == d3); // True
public class Dude
{
 public string Name;
 public Dude (string n) { Name = n; }
}
The equality and comparison operators, ==, !=, <, >, >=, and <=, work for all numeric
types, but you should use them with caution with real numbers (as we saw in “Real
Number Rounding Errors” on page 48). The comparison operators also work on
enum type members by comparing their underlying integral-type values. We describe
this in “Enums” on page 140.
We explain the equality and comparison operators in greater detail in “Operator
Overloading” on page 239, “Equality Comparison” on page 324, and “Order Com‐
parison” on page 335.
Conditional Operators
The && and || operators test for and and or conditions. They are frequently used in
conjunction with the ! operator, which expresses not. In the following example, the
UseUmbrella method returns true if it’s rainy or sunny (to protect us from the rain
or the sun), as long as it’s not also windy (umbrellas are useless in the wind):
static bool UseUmbrella (bool rainy, bool sunny, bool windy)
{
 return !windy && (rainy || sunny);
}
The && and || operators short-circuit evaluation when possible. In the preceding
example, if it is windy, the expression (rainy || sunny) is not even evaluated.
Short-circuiting is essential in allowing expressions such as the following to run
without throwing a NullReferenceException:
if (sb != null && sb.Length > 0) ...
The & and | operators also test for and and or conditions:
return !windy & (rainy | sunny);
The difference is that they do not short-circuit. For this reason, they are rarely used
in place of conditional operators.
Unlike in C and C++, the & and | operators perform (nonshort-circuiting) Boolean comparisons when applied to bool
expressions. The & and | operators perform bitwise operations
only when applied to numbers.
50 | Chapter 2: C# Language Basics
Conditional operator (ternary operator)
The conditional operator (more commonly called the ternary operator because it’s
the only operator that takes three operands) has the form q ? a : b; thus, if
condition q is true, a is evaluated, otherwise b is evaluated:
static int Max (int a, int b)
{
 return (a > b) ? a : b;
}
The conditional operator is particularly useful in LINQ expressions (Chapter 8).
Strings and Characters
C#’s char type (aliasing the System.Char type) represents a Unicode character and
occupies 2 bytes (UTF-16). A char literal is specified within single quotes:
char c = 'A'; // Simple character
Escape sequences express characters that cannot be expressed or interpreted literally.
An escape sequence is a backslash followed by a character with a special meaning;
for example:
char newLine = '\n';
char backSlash = '\\';
Table 2-2 shows the escape sequence characters.
Table 2-2. Escape sequence characters
Char Meaning Value
\' Single quote 0x0027
\" Double quote 0x0022
\\ Backslash 0x005C
\0 Null 0x0000
\a Alert 0x0007
\b Backspace 0x0008
\f Form feed 0x000C
\n New line 0x000A
\r Carriage return 0x000D
\t Horizontal tab 0x0009
\v Vertical tab 0x000B
The \u (or \x) escape sequence lets you specify any Unicode character via its
four-digit hexadecimal code:
Strings and Characters | 51
C# Language
Basics
char copyrightSymbol = '\u00A9';
char omegaSymbol = '\u03A9';
char newLine = '\u000A';
Char Conversions
An implicit conversion from a char to a numeric type works for the numeric types
that can accommodate an unsigned short. For other numeric types, an explicit
conversion is required.
String Type
C#’s string type (aliasing the System.String type, covered in depth in Chapter 6)
represents an immutable (unmodifiable) sequence of Unicode characters. A string
literal is specified within double quotes:
string a = "Heat";
string is a reference type rather than a value type. Its equality
operators, however, follow value-type semantics:
string a = "test";
string b = "test";
Console.Write (a == b); // True
The escape sequences that are valid for char literals also work inside strings:
string a = "Here's a tab:\t";
The cost of this is that whenever you need a literal backslash, you must write it
twice:
string a1 = "\\\\server\\fileshare\\helloworld.cs";
To avoid this problem, C# allows verbatim string literals. A verbatim string literal
is prefixed with @ and does not support escape sequences. The following verbatim
string is identical to the preceding one:
string a2 = @"\\server\fileshare\helloworld.cs";
A verbatim string literal can also span multiple lines:
string escaped = "First Line\r\nSecond Line";
string verbatim = @"First Line
Second Line";
// True if your text editor uses CR-LF line separators:
Console.WriteLine (escaped == verbatim);
You can include the double-quote character in a verbatim literal by writing it twice:
string xml = @"<customer id=""123""></customer>";
52 | Chapter 2: C# Language Basics
String concatenation
The + operator concatenates two strings:
string s = "a" + "b";
One of the operands might be a nonstring value, in which case ToString is called on
that value:
string s = "a" + 5; // a5
Using the + operator repeatedly to build up a string is inefficient: a better solution is
to use the System.Text.StringBuilder type (described in Chapter 6).
String interpolation
A string preceded with the $ character is called an interpolated string. Interpolated
strings can include expressions enclosed in braces:
int x = 4;
Console.Write ($"A square has {x} sides"); // Prints: A square has 4 sides
Any valid C# expression of any type can appear within the braces, and C# will
convert the expression to a string by calling its ToString method or equivalent. You
can change the formatting by appending the expression with a colon and a format
string (format strings are described in “String.Format and composite format strings”
on page 276):
string s = $"255 in hex is {byte.MaxValue:X2}"; // X2 = 2-digit hexadecimal
// Evaluates to "255 in hex is FF"
Should you need to use a colon for another purpose (such as a ternary condi‐
tional operator, which we’ll cover later), you must wrap the entire expression in
parentheses:
bool b = true;
Console.WriteLine ($"The answer in binary is {(b ? 1 : 0)}");
Interpolated strings must complete on a single line, unless you also specify the
verbatim string operator:
int x = 2;
// Note that $ must appear before @ prior to C# 8:
string s = $@"this interpolation spans {
x} lines";
To include a brace literal in an interpolated string, repeat the desired brace
character.
String comparisons
string does not support < and > operators for comparisons. You must use the
string’s CompareTo method, described in Chapter 6.
Strings and Characters | 53
C# Language
Basics
Constant interpolated strings (C# 10)
From C# 10, interpolated strings can be constants, as long as the interpolated values
are constants:
const string greeting = "Hello";
const string message = $"{greeting}, world";
Arrays
An array represents a fixed number of variables (called elements) of a particular
type. The elements in an array are always stored in a contiguous block of memory,
providing highly efficient access.
An array is denoted with square brackets after the element type:
char[] vowels = new char[5]; // Declare an array of 5 characters
Square brackets also index the array, accessing a particular element by position:
vowels[0] = 'a';
vowels[1] = 'e';
vowels[2] = 'i';
vowels[3] = 'o';
vowels[4] = 'u';
Console.WriteLine (vowels[1]); // e
This prints “e” because array indexes start at 0. You can use a for loop statement to
iterate through each element in the array. The for loop in this example cycles the
integer i from 0 to 4:
for (int i = 0; i < vowels.Length; i++)
 Console.Write (vowels[i]); // aeiou
The Length property of an array returns the number of elements in the array.
After an array has been created, you cannot change its length. The System.Collec
tion namespace and subnamespaces provide higher-level data structures, such as
dynamically sized arrays and dictionaries.
An array initialization expression lets you declare and populate an array in a single
step:
char[] vowels = new char[] {'a','e','i','o','u'};
Or simply:
char[] vowels = {'a','e','i','o','u'};
All arrays inherit from the System.Array class, providing common services for all
arrays. These members include methods to get and set elements regardless of the
array type. We describe them in “The Array Class” on page 355.
54 | Chapter 2: C# Language Basics
Default Element Initialization
Creating an array always preinitializes the elements with default values. The default
value for a type is the result of a bitwise zeroing of memory. For example, consider
creating an array of integers. Because int is a value type, this allocates 1,000 integers
in one contiguous block of memory. The default value for each element will be 0:
int[] a = new int[1000];
Console.Write (a[123]); // 0
Value types versus reference types
Whether an array element type is a value type or a reference type has important
performance implications. When the element type is a value type, each element
value is allocated as part of the array, as shown here:
Point[] a = new Point[1000];
int x = a[500].X; // 0
public struct Point { public int X, Y; }
Had Point been a class, creating the array would have merely allocated 1,000 null
references:
Point[] a = new Point[1000];
int x = a[500].X; // Runtime error, NullReferenceException
public class Point { public int X, Y; }
To avoid this error, we must explicitly instantiate 1,000 Points after instantiating the
array:
Point[] a = new Point[1000];
for (int i = 0; i < a.Length; i++) // Iterate i from 0 to 999
 a[i] = new Point(); // Set array element i with new point
An array itself is always a reference type object, regardless of the element type. For
instance, the following is legal:
int[] a = null;
Indices and Ranges
Indices and ranges (introduced in C# 8) simplify working with elements or portions
of an array.
Indices and ranges also work with the CLR types Span<T> and
ReadOnlySpan<T> (see Chapter 23).
You can also make your own types work with indices and
ranges, by defining an indexer of type Index or Range (see
“Indexers” on page 109).
Arrays | 55
C# Language
Basics
Indices
Indices let you refer to elements relative to the end of an array, with the ^ operator.
^1 refers to the last element, ^2 refers to the second-to-last element, and so on:
char[] vowels = new char[] {'a','e','i','o','u'};
char lastElement = vowels [^1]; // 'u'
char secondToLast = vowels [^2]; // 'o'
(^0 equals the length of the array, so vowels[^0] generates an error.)
C# implements indices with the help of the Index type, so you can also do the
following:
Index first = 0;
Index last = ^1;
char firstElement = vowels [first]; // 'a'
char lastElement = vowels [last]; // 'u'
Ranges
Ranges let you “slice” an array by using the .. operator:
char[] firstTwo = vowels [..2]; // 'a', 'e'
char[] lastThree = vowels [2..]; // 'i', 'o', 'u'
char[] middleOne = vowels [2..3]; // 'i'
The second number in the range is exclusive, so ..2 returns the elements before
vowels[2].
You can also use the ^ symbol in ranges. The following returns the last two
characters:
char[] lastTwo = vowels [^2..]; // 'o', 'u'
C# implements ranges with the help of the Range type, so you can also do the
following:
Range firstTwoRange = 0..2;
char[] firstTwo = vowels [firstTwoRange]; // 'a', 'e'
Multidimensional Arrays
Multidimensional arrays come in two varieties: rectangular and jagged. Rectangular
arrays represent an n-dimensional block of memory, and jagged arrays are arrays of
arrays.
Rectangular arrays
Rectangular arrays are declared using commas to separate each dimension. The
following declares a rectangular two-dimensional array for which the dimensions
are 3 by 3:
int[,] matrix = new int[3,3];
56 | Chapter 2: C# Language Basics
The GetLength method of an array returns the length for a given dimension (start‐
ing at 0):
for (int i = 0; i < matrix.GetLength(0); i++)
 for (int j = 0; j < matrix.GetLength(1); j++)
 matrix[i,j] = i * 3 + j;
You can initialize a rectangular array with explicit values. The following code creates
an array identical to the previous example:
int[,] matrix = new int[,]
{
 {0,1,2},
 {3,4,5},
 {6,7,8}
};
Jagged arrays
Jagged arrays are declared using successive square brackets to represent each
dimension. Here is an example of declaring a jagged two-dimensional array for
which the outermost dimension is 3:
int[][] matrix = new int[3][];
Interestingly, this is new int[3][] and not new int[][3].
Eric Lippert has written an excellent article on why this is so.
The inner dimensions aren’t specified in the declaration because, unlike a rectangu‐
lar array, each inner array can be an arbitrary length. Each inner array is implicitly
initialized to null rather than an empty array. You must manually create each inner
array:
for (int i = 0; i < matrix.Length; i++)
{
 matrix[i] = new int[3]; // Create inner array
 for (int j = 0; j < matrix[i].Length; j++)
 matrix[i][j] = i * 3 + j;
}
You can initialize a jagged array with explicit values. The following code creates an
array identical to the previous example with an additional element at the end:
int[][] matrix = new int[][]
{
 new int[] {0,1,2},
 new int[] {3,4,5},
 new int[] {6,7,8,9}
};
Simplified Array Initialization Expressions
There are two ways to shorten array initialization expressions. The first is to omit
the new operator and type qualifications:
Arrays | 57
C# Language
Basics
char[] vowels = {'a','e','i','o','u'};
int[,] rectangularMatrix =
{
 {0,1,2},
 {3,4,5},
 {6,7,8}
};
int[][] jaggedMatrix =
{
 new int[] {0,1,2},
 new int[] {3,4,5},
 new int[] {6,7,8,9}
};
The second approach is to use the var keyword, which instructs the compiler to
implicitly type a local variable:
var i = 3; // i is implicitly of type int
var s = "sausage"; // s is implicitly of type string
// Therefore:
var rectMatrix = new int[,] // rectMatrix is implicitly of type int[,]
{
 {0,1,2},
 {3,4,5},
 {6,7,8}
};
var jaggedMat = new int[][] // jaggedMat is implicitly of type int[][]
{
 new int[] {0,1,2},
 new int[] {3,4,5},
 new int[] {6,7,8,9}
};
Implicit typing can be taken one stage further with arrays: you can omit the type
qualifier after the new keyword and have the compiler infer the array type:
var vowels = new[] {'a','e','i','o','u'}; // Compiler infers char[]
For this to work, the elements must all be implicitly convertible to a single type (and
at least one of the elements must be of that type, and there must be exactly one best
type), as in the following example:
var x = new[] {1,10000000000}; // all convertible to long
Bounds Checking
All array indexing is bounds checked by the runtime. An IndexOutOfRange
Exception is thrown if you use an invalid index:
int[] arr = new int[3];
arr[3] = 1; // IndexOutOfRangeException thrown
58 | Chapter 2: C# Language Basics
Array bounds checking is necessary for type safety and simplifies debugging.
Generally, the performance hit from bounds checking is
minor, and the Just-in-Time (JIT) compiler can perform opti‐
mizations, such as determining in advance whether all indexes
will be safe before entering a loop, thus avoiding a check on
each iteration. In addition, C# provides “unsafe” code that
can explicitly bypass bounds checking (see “Unsafe Code and
Pointers” on page 243).
Variables and Parameters
A variable represents a storage location that has a modifiable value. A variable can
be a local variable, parameter (value, ref, out, or in), field (instance or static), or array
element.
The Stack and the Heap
The stack and the heap are the places where variables reside. Each has very different
lifetime semantics.
Stack
The stack is a block of memory for storing local variables and parameters. The stack
logically grows and shrinks as a method or function is entered and exited. Consider
the following method (to avoid distraction, input argument checking is ignored):
static int Factorial (int x)
{
 if (x == 0) return 1;
 return x * Factorial (x-1);
}
This method is recursive, meaning that it calls itself. Each time the method is
entered, a new int is allocated on the stack, and each time the method exits, the int
is deallocated.
Heap
The heap is the memory in which objects (i.e., reference-type instances) reside.
Whenever a new object is created, it is allocated on the heap, and a reference to that
object is returned. During a program’s execution, the heap begins filling up as new
objects are created. The runtime has a garbage collector that periodically deallocates
objects from the heap, so your program does not run out of memory. An object is
eligible for deallocation as soon as it’s not referenced by anything that’s itself “alive.”
In the following example, we begin by creating a StringBuilder object referenced
by the variable ref1 and then write out its content. That StringBuilder object
is then immediately eligible for garbage collection because nothing subsequently
uses it.
Variables and Parameters | 59
C# Language
Basics
Then, we create another StringBuilder referenced by variable ref2 and copy
that reference to ref3. Even though ref2 is not used after that point, ref3 keeps
the same StringBuilder object alive—ensuring that it doesn’t become eligible for
collection until we’ve finished using ref3:
using System;
using System.Text;
StringBuilder ref1 = new StringBuilder ("object1");
Console.WriteLine (ref1);
// The StringBuilder referenced by ref1 is now eligible for GC.
StringBuilder ref2 = new StringBuilder ("object2");
StringBuilder ref3 = ref2;
// The StringBuilder referenced by ref2 is NOT yet eligible for GC.
Console.WriteLine (ref3); // object2
Value-type instances (and object references) live wherever the variable was declared.
If the instance was declared as a field within a class type, or as an array element, that
instance lives on the heap.
You can’t explicitly delete objects in C#, as you can in C++.
An unreferenced object is eventually collected by the garbage
collector.
The heap also stores static fields. Unlike objects allocated on the heap (which can be
garbage-collected), these live until the process ends.
Definite Assignment
C# enforces a definite assignment policy. In practice, this means that outside of
an unsafe or interop context, you can’t accidentally access uninitialized memory.
Definite assignment has three implications:
• Local variables must be assigned a value before they can be read.
• Function arguments must be supplied when a method is called (unless marked
as optional; see “Optional parameters” on page 65).
• All other variables (such as fields and array elements) are automatically initial‐
ized by the runtime.
For example, the following code results in a compile-time error:
int x;
Console.WriteLine (x); // Compile-time error
Fields and array elements are automatically initialized with the default values for
their type. The following code outputs 0 because array elements are implicitly
assigned to their default values:
60 | Chapter 2: C# Language Basics
int[] ints = new int[2];
Console.WriteLine (ints[0]); // 0
The following code outputs 0, because fields are implicitly assigned a default value
(whether instance or static):
Console.WriteLine (Test.X); // 0
class Test { public static int X; } // field
Default Values
All type instances have a default value. The default value for the predefined types is
the result of a bitwise zeroing of memory:
Type Default value
Reference types (and nullable value types) null
Numeric and enum types 0
char type '\0'
bool type false
You can obtain the default value for any type via the default keyword:
Console.WriteLine (default (decimal)); // 0
You can optionally omit the type when it can be inferred:
decimal d = default;
The default value in a custom value type (i.e., struct) is the same as the default
value for each field defined by the custom type.
Parameters
A method may have a sequence of parameters. Parameters define the set of argu‐
ments that must be provided for that method. In the following example, the method
Foo has a single parameter named p, of type int:
Foo (8); // 8 is an argument
static void Foo (int p) {...} // p is a parameter
You can control how parameters are passed with the ref, in, and out modifiers:
Parameter modifier Passed by Variable must be definitely assigned
(None) Value Going in
ref Reference Going in
in Reference (read-only) Going in
out Reference Going out
Variables and Parameters | 61
C# Language
Basics
Passing arguments by value
By default, arguments in C# are passed by value, which is by far the most common
case. This means that a copy of the value is created when passed to the method:
int x = 8;
Foo (x); // Make a copy of x
Console.WriteLine (x); // x will still be 8
static void Foo (int p)
{
 p = p + 1; // Increment p by 1
 Console.WriteLine (p); // Write p to screen
}
Assigning p a new value does not change the contents of x, because p and x reside in
different memory locations.
Passing a reference-type argument by value copies the reference but not the object.
In the following example, Foo sees the same StringBuilder object we instantiated
(sb) but has an independent reference to it. In other words, sb and fooSB are
separate variables that reference the same StringBuilder object:
StringBuilder sb = new StringBuilder();
Foo (sb);
Console.WriteLine (sb.ToString()); // test
static void Foo (StringBuilder fooSB)
{
 fooSB.Append ("test");
 fooSB = null;
}
Because fooSB is a copy of a reference, setting it to null doesn’t make sb null. (If,
however, fooSB was declared and called with the ref modifier, sb would become
null.)
The ref modifier
To pass by reference, C# provides the ref parameter modifier. In the following
example, p and x refer to the same memory locations:
int x = 8;
Foo (ref x); // Ask Foo to deal directly with x
Console.WriteLine (x); // x is now 9
static void Foo (ref int p)
{
 p = p + 1; // Increment p by 1
 Console.WriteLine (p); // Write p to screen
}
62 | Chapter 2: C# Language Basics
4 An exception to this rule is when calling Component Object Model (COM) methods. We discuss
this in Chapter 25.
Now assigning p a new value changes the contents of x. Notice how the ref modifier
is required both when writing and when calling the method.4
 This makes it very
clear what’s going on.
The ref modifier is essential in implementing a swap method (in “Generics” on
page 145, we show how to write a swap method that works with any type):
string x = "Penn";
string y = "Teller";
Swap (ref x, ref y);
Console.WriteLine (x); // Teller
Console.WriteLine (y); // Penn
static void Swap (ref string a, ref string b)
{
 string temp = a;
 a = b;
 b = temp;
}
A parameter can be passed by reference or by value, regardless
of whether the parameter type is a reference type or a value
type.
The out modifier
An out argument is like a ref argument except for the following:
• It need not be assigned before going into the function.
• It must be assigned before it comes out of the function.
The out modifier is most commonly used to get multiple return values back from a
method; for example:
string a, b;
Split ("Stevie Ray Vaughn", out a, out b);
Console.WriteLine (a); // Stevie Ray
Console.WriteLine (b); // Vaughn
void Split (string name, out string firstNames, out string lastName)
{
 int i = name.LastIndexOf (' ');
 firstNames = name.Substring (0, i);
 lastName = name.Substring (i + 1);
}
Like a ref parameter, an out parameter is passed by reference.
Variables and Parameters | 63
C# Language
Basics
Out variables and discards
You can declare variables on the fly when calling methods with out parameters. We
can replace the first two lines in our preceding example with this:
Split ("Stevie Ray Vaughan", out string a, out string b);
When calling methods with multiple out parameters, sometimes you’re not interes‐
ted in receiving values from all the parameters. In such cases, you can “discard” the
ones in which you’re uninterested by using an underscore:
Split ("Stevie Ray Vaughan", out string a, out _); // Discard 2nd param
Console.WriteLine (a);
In this case, the compiler treats the underscore as a special symbol, called a discard.
You can include multiple discards in a single call. Assuming SomeBigMethod has
been defined with seven out parameters, we can ignore all but the fourth, as follows:
SomeBigMethod (out _, out _, out _, out int x, out _, out _, out _);
For backward compatibility, this language feature will not take effect if a real
underscore variable is in scope:
string _;
Split ("Stevie Ray Vaughan", out string a, out _);
Console.WriteLine (_); // Vaughan
Implications of passing by reference
When you pass an argument by reference, you alias the storage location of an
existing variable rather than create a new storage location. In the following example,
the variables x and y represent the same instance:
class Test
{
 static int x;
 static void Main() { Foo (out x); }
 static void Foo (out int y)
 {
 Console.WriteLine (x); // x is 0
 y = 1; // Mutate y
 Console.WriteLine (x); // x is 1
 }
}
The in modifier
An in parameter is similar to a ref parameter except that the argument’s value
cannot be modified by the method (doing so generates a compile-time error). This
modifier is most useful when passing a large value type to the method because it
allows the compiler to avoid the overhead of copying the argument prior to passing
it in while still protecting the original value from modification.
64 | Chapter 2: C# Language Basics
Overloading solely on the presence of in is permitted:
void Foo ( SomeBigStruct a) { ... }
void Foo (in SomeBigStruct a) { ... }
To call the second overload, the caller must use the in modifier:
SomeBigStruct x = ...;
Foo (x); // Calls the first overload
Foo (in x); // Calls the second overload
When there’s no ambiguity,
void Bar (in SomeBigStruct a) { ... }
use of the in modifier is optional for the caller:
Bar (x); // OK (calls the 'in' overload)
Bar (in x); // OK (calls the 'in' overload)
To make this example meaningful, SomeBigStruct would be defined as a struct (see
“Structs” on page 129).
The params modifier
The params modifier, if applied to the last parameter of a method, allows the
method to accept any number of arguments of a particular type. The parameter
type must be declared as an (single-dimensional) array, as shown in the following
example:
int total = Sum (1, 2, 3, 4);
Console.WriteLine (total); // 10
// The call to Sum above is equivalent to:
int total2 = Sum (new int[] { 1, 2, 3, 4 });
int Sum (params int[] ints)
{
 int sum = 0;
 for (int i = 0; i < ints.Length; i++)
 sum += ints [i]; // Increase sum by ints[i]
 return sum;
}
If there are zero arguments in the params position, a zero-length array is created.
You can also supply a params argument as an ordinary array. The first line in our
example is semantically equivalent to this:
int total = Sum (new int[] { 1, 2, 3, 4 } );
Optional parameters
Methods, constructors, and indexers (Chapter 3) can declare optional parameters. A
parameter is optional if it specifies a default value in its declaration:
Variables and Parameters | 65
C# Language
Basics
void Foo (int x = 23) { Console.WriteLine (x); }
You can omit optional parameters when calling the method:
Foo(); // 23
The default argument of 23 is actually passed to the optional parameter x—the com‐
piler bakes the value 23 into the compiled code at the calling side. The preceding call
to Foo is semantically identical to
Foo (23);
because the compiler simply substitutes the default value of an optional parameter
wherever it is used.
Adding an optional parameter to a public method that’s called
from another assembly requires recompilation of both assem‐
blies—just as though the parameter were mandatory.
The default value of an optional parameter must be specified by a constant expres‐
sion, a parameterless constructor of a value type, or a default expression. Optional
parameters cannot be marked with ref or out.
Mandatory parameters must occur before optional parameters in both the method
declaration and the method call (the exception is with params arguments, which still
always come last). In the following example, the explicit value of 1 is passed to x,
and the default value of 0 is passed to y:
Foo (1); // 1, 0
void Foo (int x = 0, int y = 0) { Console.WriteLine (x + ", " + y); }
You can do the converse (pass a default value to x and an explicit value to y) by
combining optional parameters with named arguments.
Named arguments
Rather than identifying an argument by position, you can identify an argument by
name:
Foo (x:1, y:2); // 1, 2
void Foo (int x, int y) { Console.WriteLine (x + ", " + y); }
Named arguments can occur in any order. The following calls to Foo are semanti‐
cally identical:
Foo (x:1, y:2);
Foo (y:2, x:1);
66 | Chapter 2: C# Language Basics
A subtle difference is that argument expressions are evalu‐
ated in the order in which they appear at the calling site.
In general, this makes a difference only with interdependent
side-effecting expressions such as the following, which writes
0, 1:
int a = 0;
Foo (y: ++a, x: --a); // ++a is evaluated first
Of course, you would almost certainly avoid writing such code
in practice!
You can mix named and positional arguments:
Foo (1, y:2);
However, there is a restriction: positional arguments must come before named
arguments unless they are used in the correct position. So, you could call Foo like
this:
Foo (x:1, 2); // OK. Arguments in the declared positions
But not like this:
Foo (y:2, 1); // Compile-time error. y isn't in the first position
Named arguments are particularly useful in conjunction with optional parameters.
For instance, consider the following method:
void Bar (int a = 0, int b = 0, int c = 0, int d = 0) { ... }
You can call this supplying only a value for d, as follows:
Bar (d:3);
This is particularly useful when calling COM APIs, which we discuss in detail in
Chapter 24.
Ref Locals
A somewhat esoteric feature of C# is that you can define a local variable that
references an element in an array or field in an object (from C# 7):
int[] numbers = { 0, 1, 2, 3, 4 };
ref int numRef = ref numbers [2];
In this example, numRef is a reference to numbers[2]. When we modify numRef, we
modify the array element:
numRef *= 10;
Console.WriteLine (numRef); // 20
Console.WriteLine (numbers [2]); // 20
The target for a ref local must be an array element, field, or local variable; it cannot
be a property (Chapter 3). Ref locals are intended for specialized micro-optimization
scenarios and are typically used in conjunction with ref returns.
Variables and Parameters | 67
C# Language
Basics
Ref Returns
The Span<T> and ReadOnlySpan<T> types that we describe
in Chapter 23 use ref returns to implement a highly effi‐
cient indexer. Outside such scenarios, ref returns are not com‐
monly used, and you can consider them a micro-optimization
feature.
You can return a ref local from a method. This is called a ref return:
class Program
{
 static string x = "Old Value";
 static ref string GetX() => ref x; // This method returns a ref
 static void Main()
 {
 ref string xRef = ref GetX(); // Assign result to a ref local
 xRef = "New Value";
 Console.WriteLine (x); // New Value
 }
}
If you omit the ref modifier on the calling side, it reverts to returning an ordinary
value:
string localX = GetX(); // Legal: localX is an ordinary non-ref variable.
You also can use ref returns when defining a property or indexer:
static ref string Prop => ref x;
Such a property is implicitly writable, despite there being no set accessor:
Prop = "New Value";
You can prevent such modification by using ref readonly:
static ref readonly string Prop => ref x;
The ref readonly modifier prevents modification while still enabling the perfor‐
mance gain of returning by reference. The gain would be very small in this case,
because x is of type string (a reference type): no matter how long the string, the
only inefficiency that you can hope to avoid is the copying of a single 32- or 64-bit
reference. Real gains can occur with custom value types (see “Structs” on page 129),
but only if the struct is marked as readonly (otherwise, the compiler will perform a
defensive copy).
Attempting to define an explicit set accessor on a ref return property or indexer is
illegal.
68 | Chapter 2: C# Language Basics
var—Implicitly Typed Local Variables
It is often the case that you declare and initialize a variable in one step. If the
compiler is able to infer the type from the initialization expression, you can use the
keyword var in place of the type declaration; for example:
var x = "hello";
var y = new System.Text.StringBuilder();
var z = (float)Math.PI;
This is precisely equivalent to the following:
string x = "hello";
System.Text.StringBuilder y = new System.Text.StringBuilder();
float z = (float)Math.PI;
Because of this direct equivalence, implicitly typed variables are statically typed. For
example, the following generates a compile-time error:
var x = 5;
x = "hello"; // Compile-time error; x is of type int
var can decrease code readability when you can’t deduce the
type purely by looking at the variable declaration; for example:
Random r = new Random();
var x = r.Next();
What type is x?
In “Anonymous Types” on page 205, we will describe a scenario in which the use of
var is mandatory.
Target-Typed new Expressions
Another way to reduce lexical repetition is with target-typed new expressions (from
C# 9):
System.Text.StringBuilder sb1 = new();
System.Text.StringBuilder sb2 = new ("Test");
This is precisely equivalent to:
System.Text.StringBuilder sb1 = new System.Text.StringBuilder();
System.Text.StringBuilder sb2 = new System.Text.StringBuilder ("Test");
The principle is that you can call new without specifying a type name if the compiler
is able to unambiguously infer it. Target-typed new expressions are particularly
useful when the variable declaration and initialization are in different parts of your
code. A common example is when you want to initialize a field in a constructor:
class Foo
{
 System.Text.StringBuilder sb;

 public Foo (string initialValue)
 {
Variables and Parameters | 69
C# Language
Basics
 sb = new (initialValue);
 }
}
Target-typed new expressions are also helpful in the following scenario:
MyMethod (new ("test"));
void MyMethod (System.Text.StringBuilder sb) { ... }
Expressions and Operators
An expression essentially denotes a value. The simplest kinds of expressions are
constants and variables. Expressions can be transformed and combined using oper‐
ators. An operator takes one or more input operands to output a new expression.
Here is an example of a constant expression:
12
We can use the * operator to combine two operands (the literal expressions 12 and
30), as follows:
12 * 30
We can build complex expressions because an operand can itself be an expression,
such as the operand (12 * 30) in the following example:
1 + (12 * 30)
Operators in C# can be classed as unary, binary, or ternary, depending on the
number of operands they work on (one, two, or three). The binary operators always
use infix notation in which the operator is placed between the two operands.
Primary Expressions
Primary expressions include expressions composed of operators that are intrinsic to
the basic plumbing of the language. Here is an example:
Math.Log (1)
This expression is composed of two primary expressions. The first expression per‐
forms a member lookup (with the . operator), and the second expression performs
a method call (with the () operator).
Void Expressions
A void expression is an expression that has no value, such as this:
Console.WriteLine (1)
Because it has no value, you cannot use a void expression as an operand to build
more complex expressions:
1 + Console.WriteLine (1) // Compile-time error
70 | Chapter 2: C# Language Basics
Assignment Expressions
An assignment expression uses the = operator to assign the result of another expres‐
sion to a variable; for example:
x = x * 5
An assignment expression is not a void expression—it has a value of whatever
was assigned, and so can be incorporated into another expression. In the following
example, the expression assigns 2 to x and 10 to y:
y = 5 * (x = 2)
You can use this style of expression to initialize multiple values:
a = b = c = d = 0
The compound assignment operators are syntactic shortcuts that combine assign‐
ment with another operator:
x *= 2 // equivalent to x = x * 2
x <<= 1 // equivalent to x = x << 1
(A subtle exception to this rule is with events, which we describe in Chapter 4: the
+= and -= operators here are treated specially and map to the event’s add and remove
accessors.)
Operator Precedence and Associativity
When an expression contains multiple operators, precedence and associativity deter‐
mine the order of their evaluation. Operators with higher precedence execute before
operators with lower precedence. If the operators have the same precedence, the
operator’s associativity determines the order of evaluation.
Precedence
The following expression
1 + 2 * 3
is evaluated as follows because * has a higher precedence than +:
1 + (2 * 3)
Left-associative operators
Binary operators (except for assignment, lambda, and null-coalescing operators) are
left-associative; in other words, they are evaluated from left to right. For example,
the following expression
8 / 4 / 2
is evaluated as follows:
( 8 / 4 ) / 2 // 1
Expressions and Operators | 71
C# Language
Basics
You can insert parentheses to change the actual order of evaluation:
8 / ( 4 / 2 ) // 4
Right-associative operators
The assignment operators as well as the lambda, null-coalescing, and conditional
operators are right-associative; in other words, they are evaluated from right to left.
Right associativity allows multiple assignments, such as the following, to compile:
x = y = 3;
This first assigns 3 to y and then assigns the result of that expression (3) to x.
Operator Table
Table 2-3 lists C#’s operators in order of precedence. Operators in the same category
have the same precedence. We explain user-overloadable operators in “Operator
Overloading” on page 239.
Table 2-3. C# operators (categories in order of precedence)
Category Operator
symbol
Operator name Example Useroverloadable
Primary . Member access x.y No
?. and ?[] Null-conditional x?.y or x?[0] No
! (postfix) Null-forgiving x!.y or x![0] No
-> (unsafe) Pointer to struct x->y No
() Function call x() No
[] Array/index a[x] Via indexer
++ Post-increment x++ Yes
−− Post-decrement x−− Yes
new Create instance new Foo() No
stackalloc Stack allocation stackalloc(10) No
typeof Get type from
identifier
typeof(int) No
nameof Get name of
identifier
nameof(x) No
checked Integral overflow
check on
checked(x) No
unchecked Integral overflow
check off
unchecked(x) No
default Default value default(char) No
Unary await Await await myTask No
72 | Chapter 2: C# Language Basics
Category Operator
symbol
Operator name Example Useroverloadable
sizeof Get size of struct sizeof(int) No
+ Positive value of +x Yes
− Negative value of −x Yes
! Not !x Yes
~ Bitwise complement ~x Yes
++ Pre-increment ++x Yes
−− Pre-decrement −−x Yes
() Cast (int)x No
^ Index from end array[^1] No
* (unsafe) Value at address *x No
& (unsafe) Address of value &x No
Range ..
..^
Range of indices x..y
x..^y
No
Switch & with switch Switch expression num switch {
1 => true,
_ => false
}
No
with With expression rec with
{ X = 123 }
No
Multiplicative * Multiply x * y Yes
/ Divide x / y Yes
% Remainder x % y Yes
Additive + Add x + y Yes
− Subtract x − y Yes
Shift << Shift left x << 1 Yes
>> Shift right x >> 1 Yes
Relational < Less than x < y Yes
> Greater than x > y Yes
<= Less than or equal
to
x <= y Yes
>= Greater than or
equal to
x >= y Yes
is Type is or is subclass
of
x is y No
as Type conversion x as y No
Equality == Equals x == y Yes
Expressions and Operators | 73
C# Language
Basics
Category Operator
symbol
Operator name Example Useroverloadable
!= Not equals x != y Yes
Logical And & And x & y Yes
Logical Xor ^ Exclusive Or x ^ y Yes
Logical Or | Or x | y Yes
Conditional And && Conditional And x && y Via &
Conditional Or || Conditional Or x || y Via |
Null coalescing ?? Null coalescing x ?? y No
Conditional ?: Conditional isTrue ? thenThis
: elseThis
No
Assignment
and lambda
= Assign x = y No
*= Multiply self by x *= 2 Via *
/= Divide self by x /= 2 Via /
%= Remainder & assign
to self
x %= 2
+= Add to self x += 2 Via +
−= Subtract from self x −= 2 Via −
<<= Shift self left by x <<= 2 Via <<
>>= Shift self right by x >>= 2 Via >>
&= And self by x &= 2 Via &
^= Exclusive-Or self by x ^= 2 Via ^
|= Or self by x |= 2 Via |
??= Null-coalescing
assignment
x ??= 0 No
=> Lambda x => x + 1 No
Null Operators
C# provides three operators to make it easier to work with nulls: the null-coalescing
operator, the null-coalescing assignment operator, and the null-conditional operator.
Null-Coalescing Operator
The ?? operator is the null-coalescing operator. It says, “If the operand to the left is
non-null, give it to me; otherwise, give me another value.” For example:
string s1 = null;
string s2 = s1 ?? "nothing"; // s2 evaluates to "nothing"
74 | Chapter 2: C# Language Basics
If the lefthand expression is non-null, the righthand expression is never evaluated.
The null-coalescing operator also works with nullable value types (see “Nullable
Value Types” on page 194).
Null-Coalescing Assignment Operator
The ??= operator (introduced in C# 8) is the null-coalescing assignment operator. It
says, “If the operand to the left is null, assign the right operand to the left operand.”
Consider the following:
myVariable ??= someDefault;
This is equivalent to:
if (myVariable == null) myVariable = someDefault;
The ??= operator is particularly useful in implementing lazily calculated properties.
We’ll cover this topic later, in “Calculated Fields and Lazy Evaluation” on page 217.
Null-Conditional Operator
The ?. operator is the null-conditional or “Elvis” operator (after the Elvis emoticon).
It allows you to call methods and access members just like the standard dot operator
except that if the operand on the left is null, the expression evaluates to null instead
of throwing a NullReferenceException:
System.Text.StringBuilder sb = null;
string s = sb?.ToString(); // No error; s instead evaluates to null
The last line is equivalent to the following:
string s = (sb == null ? null : sb.ToString());
Null-conditional expressions also work with indexers:
string foo = null;
char? c = foo?[1]; // c is null
Upon encountering a null, the Elvis operator short-circuits the remainder of the
expression. In the following example, s evaluates to null, even with a standard dot
operator between ToString() and ToUpper():
System.Text.StringBuilder sb = null;
string s = sb?.ToString().ToUpper(); // s evaluates to null without error
Repeated use of Elvis is necessary only if the operand immediately to its left might
be null. The following expression is robust to both x being null and x.y being null:
x?.y?.z
It is equivalent to the following (except that x.y is evaluated only once):
x == null ? null
 : (x.y == null ? null : x.y.z)
The final expression must be capable of accepting a null. The following is illegal:
Null Operators | 75
C# Language
Basics
System.Text.StringBuilder sb = null;
int length = sb?.ToString().Length; // Illegal : int cannot be null
We can fix this with the use of nullable value types (see “Nullable Value Types” on
page 194). If you’re already familiar with nullable value types, here’s a preview:
int? length = sb?.ToString().Length; // OK: int? can be null
You can also use the null-conditional operator to call a void method:
someObject?.SomeVoidMethod();
If someObject is null, this becomes a “no-operation” rather than throwing a Null
ReferenceException.
You can use the null-conditional operator with the commonly used type members
that we describe in Chapter 3, including methods, fields, properties, and indexers. It
also combines well with the null-coalescing operator:
System.Text.StringBuilder sb = null;
string s = sb?.ToString() ?? "nothing"; // s evaluates to "nothing"
Statements
Functions comprise statements that execute sequentially in the textual order in
which they appear. A statement block is a series of statements appearing between
braces (the {} tokens).
Declaration Statements
A variable declaration introduces a new variable, optionally initializing it with
an expression. You may declare multiple variables of the same type in a commaseparated list:
string someWord = "rosebud";
int someNumber = 42;
bool rich = true, famous = false;
A constant declaration is like a variable declaration except that it cannot be changed
after it has been declared, and the initialization must occur with the declaration (see
“Constants” on page 96):
const double c = 2.99792458E08;
c += 10; // Compile-time Error
Local variables
The scope of a local variable or local constant extends throughout the current block.
You cannot declare another local variable with the same name in the current block
or in any nested blocks:
int x;
{
 int y;
 int x; // Error - x already defined
76 | Chapter 2: C# Language Basics
}
{
 int y; // OK - y not in scope
}
Console.Write (y); // Error - y is out of scope
A variable’s scope extends in both directions throughout its
code block. This means that if we moved the initial declara‐
tion of x in this example to the bottom of the method, we’d
get the same error. This is in contrast to C++ and is somewhat
peculiar, given that it’s not legal to refer to a variable or con‐
stant before it’s declared.
Expression Statements
Expression statements are expressions that are also valid statements. An expression
statement must either change state or call something that might change state.
Changing state essentially means changing a variable. Following are the possible
expression statements:
• Assignment expressions (including increment and decrement expressions)
• Method call expressions (both void and nonvoid)
• Object instantiation expressions
Here are some examples:
// Declare variables with declaration statements:
string s;
int x, y;
System.Text.StringBuilder sb;
// Expression statements
x = 1 + 2; // Assignment expression
x++; // Increment expression
y = Math.Max (x, 5); // Assignment expression
Console.WriteLine (y); // Method call expression
sb = new StringBuilder(); // Assignment expression
new StringBuilder(); // Object instantiation expression
When you call a constructor or a method that returns a value, you’re not obliged
to use the result. However, unless the constructor or method changes state, the
statement is completely useless:
new StringBuilder(); // Legal, but useless
new string ('c', 3); // Legal, but useless
x.Equals (y); // Legal, but useless
Statements | 77
C# Language
Basics
Selection Statements
C# has the following mechanisms to conditionally control the flow of program
execution:
• Selection statements (if, switch)
• Conditional operator (?:)
• Loop statements (while, do-while, for, foreach)
This section covers the simplest two constructs: the if statement and the switch
statement.
The if statement
An if statement executes a statement if a bool expression is true:
if (5 < 2 * 3)
 Console.WriteLine ("true"); // true
The statement can be a code block:
if (5 < 2 * 3)
{
 Console.WriteLine ("true");
 Console.WriteLine ("Let’s move on!");
}
The else clause
An if statement can optionally feature an else clause:
if (2 + 2 == 5)
 Console.WriteLine ("Does not compute");
else
 Console.WriteLine ("False"); // False
Within an else clause, you can nest another if statement:
if (2 + 2 == 5)
 Console.WriteLine ("Does not compute");
else
 if (2 + 2 == 4)
 Console.WriteLine ("Computes"); // Computes
Changing the flow of execution with braces
An else clause always applies to the immediately preceding if statement in the
statement block:
if (true)
 if (false)
 Console.WriteLine();
78 | Chapter 2: C# Language Basics
 else
 Console.WriteLine ("executes");
This is semantically identical to the following:
if (true)
{
 if (false)
 Console.WriteLine();
 else
 Console.WriteLine ("executes");
}
We can change the execution flow by moving the braces:
if (true)
{
 if (false)
 Console.WriteLine();
}
else
 Console.WriteLine ("does not execute");
With braces, you explicitly state your intention. This can improve the readability of
nested if statements—even when not required by the compiler. A notable exception
is with the following pattern:
void TellMeWhatICanDo (int age)
{
 if (age >= 35)
 Console.WriteLine ("You can be president!");
 else if (age >= 21)
 Console.WriteLine ("You can drink!");
 else if (age >= 18)
 Console.WriteLine ("You can vote!");
 else
 Console.WriteLine ("You can wait!");
}
Here, we’ve arranged the if and else statements to mimic the “elseif ” construct
of other languages (and C#’s #elif preprocessor directive). Visual Studio’s autoformatting recognizes this pattern and preserves the indentation. Semantically,
though, each if statement following an else statement is functionally nested within
the else clause.
The switch statement
switch statements let you branch program execution based on a selection of possi‐
ble values that a variable might have. switch statements can result in cleaner code
than multiple if statements because switch statements require an expression to be
evaluated only once:
void ShowCard (int cardNumber)
{
 switch (cardNumber)
Statements | 79
C# Language
Basics
 {
 case 13:
 Console.WriteLine ("King");
 break;
 case 12:
 Console.WriteLine ("Queen");
 break;
 case 11:
 Console.WriteLine ("Jack");
 break;
 case -1: // Joker is -1
 goto case 12; // In this game joker counts as queen
 default: // Executes for any other cardNumber
 Console.WriteLine (cardNumber);
 break;
 }
}
This example demonstrates the most common scenario, which is switching on
constants. When you specify a constant, you’re restricted to the built-in integral
types; the bool, char, and enum types; and the string type.
At the end of each case clause, you must specify explicitly where execution is to go
next, with some kind of jump statement (unless your code ends in an infinite loop).
Here are the options:
• break (jumps to the end of the switch statement)
• goto case x (jumps to another case clause)
• goto default (jumps to the default clause)
• Any other jump statement—namely, return, throw, continue, or goto label
When more than one value should execute the same code, you can list the common
cases sequentially:
switch (cardNumber)
{
 case 13:
 case 12:
 case 11:
 Console.WriteLine ("Face card");
 break;
 default:
 Console.WriteLine ("Plain card");
 break;
}
This feature of a switch statement can be pivotal in terms of producing cleaner code
than multiple if-else statements.
80 | Chapter 2: C# Language Basics
Switching on types
Switching on a type is a special case of switching on a pattern.
A number of other patterns have been introduced in recent
versions of C#; see “Patterns” on page 222 for a full discussion.
You can also switch on types (from C# 7):
TellMeTheType (12);
TellMeTheType ("hello");
TellMeTheType (true);
void TellMeTheType (object x) // object allows any type.
{
 switch (x)
 {
 case int i:
 Console.WriteLine ("It's an int!");
 Console.WriteLine ($"The square of {i} is {i * i}");
 break;
 case string s:
 Console.WriteLine ("It's a string");
 Console.WriteLine ($"The length of {s} is {s.Length}");
 break;
 default:
 Console.WriteLine ("I don't know what x is");
 break;
 }
}
(The object type allows for a variable of any type; we discuss this fully in “Inheri‐
tance” on page 115 and “The object Type” on page 125.)
Each case clause specifies a type upon which to match, and a variable upon which
to assign the typed value if the match succeeds (the “pattern” variable). Unlike with
constants, there’s no restriction on what types you can use.
You can predicate a case with the when keyword:
switch (x)
{
 case bool b when b == true: // Fires only when b is true
 Console.WriteLine ("True!");
 break;
 case bool b:
 Console.WriteLine ("False!");
 break;
}
The order of the case clauses can matter when switching on type (unlike when
switching on constants). This example would give a different result if we reversed
the two cases (in fact, it would not even compile, because the compiler would
determine that the second case is unreachable). An exception to this rule is the
default clause, which is always executed last, regardless of where it appears.
Statements | 81
C# Language
Basics
If you want to switch on a type, but are uninterested in its value, you can use a
discard (_):
 case DateTime _:
 Console.WriteLine ("It's a DateTime");
You can stack multiple case clauses. The Console.WriteLine in the following code
will execute for any floating-point type greater than 1,000:
switch (x)
{
 case float f when f > 1000:
 case double d when d > 1000:
 case decimal m when m > 1000:
 Console.WriteLine ("We can refer to x here but not f or d or m");
 break;
}
In this example, the compiler lets us consume the pattern variables f, d, and m, only
in the when clauses. When we call Console.WriteLine, its unknown which one of
those three variables will be assigned, so the compiler puts all of them out of scope.
You can mix and match constants and patterns in the same switch statement. And
you can also switch on the null value:
case null:
 Console.WriteLine ("Nothing here");
 break;
Switch expressions
From C# 8, you can use switch in the context of an expression. Assuming that
cardNumber is of type int, the following illustrates its use:
string cardName = cardNumber switch
{
 13 => "King",
 12 => "Queen",
 11 => "Jack",
 _ => "Pip card" // equivalent to 'default'
};
Notice that the switch keyword appears after the variable name and that the case
clauses are expressions (terminated by commas) rather than statements. Switch
expressions are more compact than their switch statement counterparts, and you
can use them in LINQ queries (Chapter 8).
If you omit the default expression (_) and the switch fails to match, an exception is
thrown.
You can also switch on multiple values (the tuple pattern):
int cardNumber = 12;
string suite = "spades";
82 | Chapter 2: C# Language Basics
string cardName = (cardNumber, suite) switch
{
 (13, "spades") => "King of spades",
 (13, "clubs") => "King of clubs",
 ...
};
Many more options are possible through the use of patterns (see “Patterns” on page
222).
Iteration Statements
C# enables a sequence of statements to execute repeatedly with the while, do-while,
for, and foreach statements.
while and do-while loops
while loops repeatedly execute a body of code while a bool expression is true.
The expression is tested before the body of the loop is executed. For example, the
following writes 012:
int i = 0;
while (i < 3)
{
 Console.Write (i);
 i++;
}
do-while loops differ in functionality from while loops only in that they test the
expression after the statement block has executed (ensuring that the block is always
executed at least once). Here’s the preceding example rewritten with a do-while
loop:
int i = 0;
do
{
 Console.WriteLine (i);
 i++;
}
while (i < 3);
for loops
for loops are like while loops with special clauses for initialization and iteration of a
loop variable. A for loop contains three clauses as follows:
for (initialization-clause; condition-clause; iteration-clause)
 statement-or-statement-block
Statements | 83
C# Language
Basics
Here’s what each clause does:
Initialization clause
Executed before the loop begins; used to initialize one or more iteration vari‐
ables
Condition clause
The bool expression that, while true, will execute the body
Iteration clause
Executed after each iteration of the statement block; used typically to update
the iteration variable
For example, the following prints the numbers 0 through 2:
for (int i = 0; i < 3; i++)
 Console.WriteLine (i);
The following prints the first 10 Fibonacci numbers (in which each number is the
sum of the previous two):
for (int i = 0, prevFib = 1, curFib = 1; i < 10; i++)
{
 Console.WriteLine (prevFib);
 int newFib = prevFib + curFib;
 prevFib = curFib; curFib = newFib;
}
Any of the three parts of the for statement can be omitted. You can implement an
infinite loop such as the following (though while(true) can be used, instead):
for (;;)
 Console.WriteLine ("interrupt me");
foreach loops
The foreach statement iterates over each element in an enumerable object. Most of
the .NET types that represent a set or list of elements are enumerable. For example,
both an array and a string are enumerable. Here is an example of enumerating over
the characters in a string, from the first character through to the last:
foreach (char c in "beer") // c is the iteration variable
 Console.WriteLine (c);
Here’s the output:
b
e
e
r
We define enumerable objects in “Enumeration and Iterators” on page 189.
84 | Chapter 2: C# Language Basics
Jump Statements
The C# jump statements are break, continue, goto, return, and throw.
Jump statements obey the reliability rules of try statements
(see “try Statements and Exceptions” on page 181). This
means that:
• A jump out of a try block always executes the try’s
finally block before reaching the target of the jump.
• A jump cannot be made from the inside to the outside of
a finally block (except via throw).
The break statement
The break statement ends the execution of the body of an iteration or switch
statement:
int x = 0;
while (true)
{
 if (x++ > 5)
 break; // break from the loop
}
// execution continues here after break
...
The continue statement
The continue statement forgoes the remaining statements in a loop and makes an
early start on the next iteration. The following loop skips even numbers:
for (int i = 0; i < 10; i++)
{
 if ((i % 2) == 0) // If i is even,
 continue; // continue with next iteration
 Console.Write (i + " ");
}
OUTPUT: 1 3 5 7 9
The goto statement
The goto statement transfers execution to another label within a statement block.
The form is as follows:
goto statement-label;
Or, when used within a switch statement:
goto case case-constant; // (Only works with constants, not patterns)
Statements | 85
C# Language
Basics
A label is a placeholder in a code block that precedes a statement, denoted with a
colon suffix. The following iterates the numbers 1 through 5, mimicking a for loop:
int i = 1;
startLoop:
if (i <= 5)
{
 Console.Write (i + " ");
 i++;
 goto startLoop;
}
OUTPUT: 1 2 3 4 5
The goto case case-constant transfers execution to another case in a switch
block (see “The switch statement” on page 79).
The return statement
The return statement exits the method and must return an expression of the
method’s return type if the method is nonvoid:
decimal AsPercentage (decimal d)
{
 decimal p = d * 100m;
 return p; // Return to the calling method with value
}
A return statement can appear anywhere in a method (except in a finally block)
and can be used more than once.
The throw statement
The throw statement throws an exception to indicate an error has occurred (see “try
Statements and Exceptions” on page 181):
if (w == null)
 throw new ArgumentNullException (...);
Miscellaneous Statements
The using statement provides an elegant syntax for calling Dispose on objects
that implement IDisposable, within a finally block (see “try Statements and
Exceptions” on page 181 and “IDisposable, Dispose, and Close” on page 557).
C# overloads the using keyword to have independent mean‐
ings in different contexts. Specifically, the using directive is
different from the using statement.
The lock statement is a shortcut for calling the Enter and Exit methods of the
Monitor class (see Chapters 14 and 23).
86 | Chapter 2: C# Language Basics
Namespaces
A namespace is a domain for type names. Types are typically organized into hier‐
archical namespaces, making them easier to find and preventing conflicts. For
example, the RSA type that handles public key encryption is defined within the
following namespace:
System.Security.Cryptography
A namespace forms an integral part of a type’s name. The following code calls RSA’s
Create method:
System.Security.Cryptography.RSA rsa =
 System.Security.Cryptography.RSA.Create();
Namespaces are independent of assemblies, which are .dll files
that serve as units of deployment (described in Chapter 17).
Namespaces also have no impact on member visibility—pub
lic, internal, private, and so on.
The namespace keyword defines a namespace for types within that block; for
example:
namespace Outer.Middle.Inner
{
 class Class1 {}
 class Class2 {}
}
The dots in the namespace indicate a hierarchy of nested namespaces. The code that
follows is semantically identical to the preceding example:
namespace Outer
{
 namespace Middle
 {
 namespace Inner
 {
 class Class1 {}
 class Class2 {}
 }
 }
}
You can refer to a type with its fully qualified name, which includes all namespaces
from the outermost to the innermost. For example, we could refer to Class1 in the
preceding example as Outer.Middle.Inner.Class1.
Types not defined in any namespace are said to reside in the global namespace. The
global namespace also includes top-level namespaces, such as Outer in our example.
Namespaces | 87
C# Language
Basics
File-Scoped Namespaces (C# 10)
Often, you will want all the types in a file to be defined in one namespace:
namespace MyNamespace
{
 class Class1 {}
 class Class2 {}
}
From C# 10, you can accomplish this with a file-scoped namespace:
namespace MyNamespace; // Applies to everything that follows in the file.
class Class1 {} // inside MyNamespace
class Class2 {} // inside MyNamespace
File-scoped namespaces reduce clutter and eliminate an unnecessary level of
indentation.
The using Directive
The using directive imports a namespace, allowing you to refer to types without
their fully qualified names. The following imports the previous example’s Outer.Mid
dle.Inner namespace:
using Outer.Middle.Inner;
Class1 c; // Don’t need fully qualified name
It’s legal (and often desirable) to define the same type name
in different namespaces. However, you’d typically do so only
if it was unlikely for a consumer to want to import both
namespaces at once. A good example is the TextBox class,
which is defined both in System.Windows.Controls (WPF)
and System.Windows.Forms (Windows Forms).
A using directive can be nested within a namespace itself to limit the scope of the
directive.
The global using Directive (C# 10)
From C# 10, if you prefix a using directive with the global keyword, the directive
will apply to all files in the project or compilation unit:
global using System;
global using System.Collection.Generic;
This lets you centralize common imports and avoid repeating the same directives in
every file.
global using directives must precede nonglobal directives and cannot appear
inside namespace declarations. The global directive can be used with using static.
88 | Chapter 2: C# Language Basics
Implicit global usings
From .NET 6, project files allow for implicit global using directives. If the
ImplicitUsings element is set to true in the project file (the default for new
projects), the following namespaces are automatically imported:
System
System.Collections.Generic
System.IO
System.Linq
System.Net.Http
System.Threading
System.Threading.Tasks
Additional namespaces are imported, based on the project SDK (Web, Windows
Forms, WPF, and so on).
using static
The using static directive imports a type rather than a namespace. All static
members of the imported type can then be used without qualification. In the follow‐
ing example, we call the Console class’s static WriteLine method without needing to
refer to the type:
using static System.Console;
WriteLine ("Hello");
The using static directive imports all accessible static members of the type,
including fields, properties, and nested types (Chapter 3). You can also apply this
directive to enum types (Chapter 3), in which case their members are imported. So,
if we import the following enum type
using static System.Windows.Visibility;
we can specify Hidden instead of Visibility.Hidden:
var textBox = new TextBox { Visibility = Hidden }; // XAML-style
Should an ambiguity arise between multiple static imports, the C# compiler is not
smart enough to infer the correct type from the context and will generate an error.
Rules Within a Namespace
Name scoping
Names declared in outer namespaces can be used unqualified within inner name‐
spaces. In this example, Class1 does not need qualification within Inner:
namespace Outer
{
 class Class1 {}
 namespace Inner
Namespaces | 89
C# Language
Basics
 {
 class Class2 : Class1 {}
 }
}
If you want to refer to a type in a different branch of your namespace hierarchy, you
can use a partially qualified name. In the following example, we base SalesReport
on Common.ReportBase:
namespace MyTradingCompany
{
 namespace Common
 {
 class ReportBase {}
 }
 namespace ManagementReporting
 {
 class SalesReport : Common.ReportBase {}
 }
}
Name hiding
If the same type name appears in both an inner and an outer namespace, the inner
name wins. To refer to the type in the outer namespace, you must qualify its name:
namespace Outer
{
 class Foo { }
 namespace Inner
 {
 class Foo { }
 class Test
 {
 Foo f1; // = Outer.Inner.Foo
 Outer.Foo f2; // = Outer.Foo
 }
 }
}
All type names are converted to fully qualified names at
compile time. Intermediate Language (IL) code contains no
unqualified or partially qualified names.
Repeated namespaces
You can repeat a namespace declaration, as long as the type names within the
namespaces don’t conflict:
namespace Outer.Middle.Inner
{
 class Class1 {}
}
90 | Chapter 2: C# Language Basics
namespace Outer.Middle.Inner
{
 class Class2 {}
}
We can even break the example into two source files such that we could compile
each class into a different assembly.
Source file 1:
namespace Outer.Middle.Inner
{
 class Class1 {}
}
Source file 2:
namespace Outer.Middle.Inner
{
 class Class2 {}
}
Nested using directives
You can nest a using directive within a namespace. This allows you to scope the
using directive within a namespace declaration. In the following example, Class1 is
visible in one scope but not in another:
namespace N1
{
 class Class1 {}
}
namespace N2
{
 using N1;
 class Class2 : Class1 {}
}
namespace N2
{
 class Class3 : Class1 {} // Compile-time error
}
Aliasing Types and Namespaces
Importing a namespace can result in type-name collision. Rather than importing
the entire namespace, you can import just the specific types that you need, giving
each type an alias:
using PropertyInfo2 = System.Reflection.PropertyInfo;
class Program { PropertyInfo2 p; }
Namespaces | 91
C# Language
Basics
An entire namespace can be aliased, as follows:
using R = System.Reflection;
class Program { R.PropertyInfo p; }
Advanced Namespace Features
Extern
Extern aliases allow your program to reference two types with the same fully
qualified name (i.e., the namespace and type name are identical). This is an unusual
scenario and can occur only when the two types come from different assemblies.
Consider the following example.
Library 1, compiled to Widgets1.dll:
namespace Widgets
{
 public class Widget {}
}
Library 2, compiled to Widgets2.dll:
namespace Widgets
{
 public class Widget {}
}
Application, which references Widgets1.dll and Widgets2.dll:
using Widgets;
Widget w = new Widget();
The application cannot compile, because Widget is ambiguous. Extern aliases can
resolve the ambiguity. The first step is to modify the application’s .csproj file, assign‐
ing a unique alias to each reference:
<ItemGroup>
 <Reference Include="Widgets1">
 <Aliases>W1</Aliases>
 </Reference>
 <Reference Include="Widgets2">
 <Aliases>W2</Aliases>
 </Reference>
</ItemGroup>
The second step is to use the extern alias directive:
extern alias W1;
extern alias W2;
W1.Widgets.Widget w1 = new W1.Widgets.Widget();
W2.Widgets.Widget w2 = new W2.Widgets.Widget();
92 | Chapter 2: C# Language Basics
Namespace alias qualifiers
As we mentioned earlier, names in inner namespaces hide names in outer namespa‐
ces. However, sometimes even the use of a fully qualified type name does not resolve
the conflict. Consider the following example:
namespace N
{
 class A
 {
 static void Main() => new A.B(); // Instantiate class B
 public class B {} // Nested type
 }
}
namespace A
{
 class B {}
}
The Main method could be instantiating either the nested class B or the class B
within the namespace A. The compiler always gives higher precedence to identifiers
in the current namespace, in this case the nested B class.
To resolve such conflicts, a namespace name can be qualified, relative to one of the
following:
• The global namespace—the root of all namespaces (identified with the contex‐
tual keyword global)
• The set of extern aliases
The :: token performs namespace alias qualification. In this example, we qualify
using the global namespace (this is most commonly seen in autogenerated code to
avoid name conflicts):
namespace N
{
 class A
 {
 static void Main()
 {
 System.Console.WriteLine (new A.B());
 System.Console.WriteLine (new global::A.B());
 }
 public class B {}
 }
}
namespace A
{
 class B {}
}
Namespaces | 93
C# Language
Basics
Here is an example of qualifying with an alias (adapted from the example in
“Extern”):
extern alias W1;
extern alias W2;
W1::Widgets.Widget w1 = new W1::Widgets.Widget();
W2::Widgets.Widget w2 = new W2::Widgets.Widget();
94 | Chapter 2: C# Language Basics
3
Creating Types in C#
In this chapter, we delve into types and type members.
Classes
A class is the most common kind of reference type. The simplest possible class
declaration is as follows:
class YourClassName
{
}
A more complex class optionally has the following:
Preceding the keyword
class
Attributes and class modifiers. The non-nested class modifiers are public,
internal, abstract, sealed, static, unsafe, and partial.
Following Your
ClassName
Generic type parameters and constraints, a base class, and interfaces.
Within the braces Class members (these are methods, properties, indexers, events, fields, constructors,
overloaded operators, nested types, and a finalizer).
This chapter covers all of these constructs except attributes, operator functions,
and the unsafe keyword, which are covered in Chapter 4. The following sections
enumerate each of the class members.
Fields
A field is a variable that is a member of a class or struct; for example:
class Octopus
{
 string name;
 public int Age = 10;
}
95
Fields allow the following modifiers:
Static modifier static
Access modifiers public internal private protected
Inheritance modifier new
Unsafe code modifier unsafe
Read-only modifier readonly
Threading modifier volatile
There are two popular naming conventions for private fields: camel-cased (e.g.,
firstName) and camel-cased with an underscore (_firstName). The latter conven‐
tion lets you instantly distinguish private fields from parameters and local variables.
The readonly modifier
The readonly modifier prevents a field from being modified after construction. A
read-only field can be assigned only in its declaration or within the enclosing type’s
constructor.
Field initialization
Field initialization is optional. An uninitialized field has a default value (0, '\0',
null, false). Field initializers run before constructors:
public int Age = 10;
A field initializer can contain expressions and call methods:
static readonly string TempFolder = System.IO.Path.GetTempPath();
Declaring multiple fields together
For convenience, you can declare multiple fields of the same type in a commaseparated list. This is a convenient way for all the fields to share the same attributes
and field modifiers:
static readonly int legs = 8,
 eyes = 2;
Constants
A constant is evaluated statically at compile time, and the compiler literally substi‐
tutes its value whenever used (rather like a macro in C++). A constant can be bool,
char, string, any of the built-in numeric types, or an enum type.
A constant is declared with the const keyword and must be initialized with a value.
For example:
96 | Chapter 3: Creating Types in C#
public class Test
{
 public const string Message = "Hello World";
}
A constant can serve a similar role to a static readonly field, but it is much more
restrictive—both in the types you can use and in field initialization semantics. A
constant also differs from a static readonly field in that the evaluation of the
constant occurs at compile time; thus
public static double Circumference (double radius)
{
 return 2 * System.Math.PI * radius;
}
is compiled to:
public static double Circumference (double radius)
{
 return 6.2831853071795862 * radius;
}
It makes sense for PI to be a constant because its value is predetermined at compile
time. In contrast, a static readonly field’s value can potentially differ each time
the program is run:
static readonly DateTime StartupTime = DateTime.Now;
A static readonly field is also advantageous when exposing
to other assemblies a value that might change in a later ver‐
sion. For instance, suppose that assembly X exposes a constant
as follows:
public const decimal ProgramVersion = 2.3;
If assembly Y references X and uses this constant, the value
2.3 will be baked into assembly Y when compiled. This means
that if X is later recompiled with the constant set to 2.4, Y will
still use the old value of 2.3 until Y is recompiled. A static
readonly field avoids this problem.
Another way of looking at this is that any value that might
change in the future is not constant by definition; thus, it
should not be represented as one.
Constants can also be declared local to a method:
void Test()
{
 const double twoPI = 2 * System.Math.PI;
 ...
}
Classes | 97
Creating
Types in C#
Nonlocal constants allow the following modifiers:
Access modifiers public internal private protected
Inheritance modifier new
Methods
A method performs an action in a series of statements. A method can receive input
data from the caller by specifying parameters, and output data back to the caller by
specifying a return type. A method can specify a void return type, indicating that
it doesn’t return any value to its caller. A method can also output data back to the
caller via ref/out parameters.
A method’s signature must be unique within the type. A method’s signature compri‐
ses its name and parameter types in order (but not the parameter names, nor the
return type).
Methods allow the following modifiers:
Static modifier static
Access modifiers public internal private protected
Inheritance modifiers new virtual abstract override sealed
Partial method modifier partial
Unmanaged code modifiers unsafe extern
Asynchronous code modifier async
Expression-bodied methods
A method that comprises a single expression, such as
int Foo (int x) { return x * 2; }
can be written more tersely as an expression-bodied method. A fat arrow replaces the
braces and return keyword:
int Foo (int x) => x * 2;
Expression-bodied functions can also have a void return type:
void Foo (int x) => Console.WriteLine (x);
Local methods
You can define a method within another method:
void WriteCubes()
{
 Console.WriteLine (Cube (3));
 Console.WriteLine (Cube (4));
 Console.WriteLine (Cube (5));
98 | Chapter 3: Creating Types in C#
 int Cube (int value) => value * value * value;
}
The local method (Cube, in this case) is visible only to the enclosing method (Write
Cubes). This simplifies the containing type and instantly signals to anyone looking
at the code that Cube is used nowhere else. Another benefit of local methods is that
they can access the local variables and parameters of the enclosing method. This
has a number of consequences, which we describe in detail in “Capturing Outer
Variables” on page 176.
Local methods can appear within other function kinds, such as property accessors,
constructors, and so on. You can even put local methods inside other local methods
and inside lambda expressions that use a statement block (Chapter 4). Local meth‐
ods can be iterators (Chapter 4) or asynchronous (Chapter 14).
Static local methods
Adding the static modifier to a local method (from C# 8) prevents it from seeing
the local variables and parameters of the enclosing method. This helps to reduce
coupling and prevents the local method from accidentally referring to variables in
the containing method.
Local methods and top-level statements
Any methods that you declare in top-level statements are treated as local methods.
This means that (unless marked as static) they can access the variables in the
top-level statements:
int x = 3;
Foo();
void Foo() => Console.WriteLine (x);
Overloading methods
Local methods cannot be overloaded. This means that meth‐
ods declared in top-level statements (which are treated as local
methods) cannot be overloaded.
A type can overload methods (define multiple methods with the same name) as long
as the signatures are different. For example, the following methods can all coexist in
the same type:
void Foo (int x) {...}
void Foo (double x) {...}
void Foo (int x, float y) {...}
void Foo (float x, int y) {...}
However, the following pairs of methods cannot coexist in the same type, because
the return type and the params modifier are not part of a method’s signature:
Classes | 99
Creating
Types in C#
void Foo (int x) {...}
float Foo (int x) {...} // Compile-time error
void Goo (int[] x) {...}
void Goo (params int[] x) {...} // Compile-time error
Whether a parameter is pass-by-value or pass-by-reference is also part of the signa‐
ture. For example, Foo(int) can coexist with either Foo(ref int) or Foo(out int).
However, Foo(ref int) and Foo(out int) cannot coexist:
void Foo (int x) {...}
void Foo (ref int x) {...} // OK so far
void Foo (out int x) {...} // Compile-time error
Instance Constructors
Constructors run initialization code on a class or struct. A constructor is defined
like a method, except that the method name and return type are reduced to the
name of the enclosing type:
Panda p = new Panda ("Petey"); // Call constructor
public class Panda
{
 string name; // Define field
 public Panda (string n) // Define constructor
 {
 name = n; // Initialization code (set up field)
 }
}
Instance constructors allow the following modifiers:
Access modifiers public internal private protected
Unmanaged code modifiers unsafe extern
Single-statement constructors can also be written as expression-bodied members:
public Panda (string n) => name = n;
Overloading constructors
A class or struct may overload constructors. To avoid code duplication, one con‐
structor can call another, using the this keyword:
using System;
public class Wine
{
 public decimal Price;
 public int Year;
 public Wine (decimal price) { Price = price; }
100 | Chapter 3: Creating Types in C#
 public Wine (decimal price, int year) : this (price) { Year = year; }
}
When one constructor calls another, the called constructor executes first.
You can pass an expression into another constructor, as follows:
public Wine (decimal price, DateTime year) : this (price, year.Year) { }
The expression itself cannot make use of the this reference, for example, to call an
instance method. (This is enforced because the object has not been initialized by the
constructor at this stage, so any methods that you call on it are likely to fail.) It can,
however, call static methods.
Implicit parameterless constructors
For classes, the C# compiler automatically generates a parameterless public con‐
structor if and only if you do not define any constructors. However, as soon as
you define at least one constructor, the parameterless constructor is no longer
automatically generated.
Constructor and field initialization order
We previously saw that fields can be initialized with default values in their
declaration:
class Player
{
 int shields = 50; // Initialized first
 int health = 100; // Initialized second
}
Field initializations occur before the constructor is executed, and in the declaration
order of the fields.
Nonpublic constructors
Constructors do not need to be public. A common reason to have a nonpublic con‐
structor is to control instance creation via a static method call. The static method
could be used to return an object from a pool rather than creating a new object, or
to return various subclasses based on input arguments:
public class Class1
{
 Class1() {} // Private constructor
 public static Class1 Create (...)
 {
 // Perform custom logic here to return an instance of Class1
 ...
 }
}
Classes | 101
Creating
Types in C#
Deconstructors
A deconstructor (also called a deconstructing method) acts as an approximate oppo‐
site to a constructor: whereas a constructor typically takes a set of values (as
parameters) and assigns them to fields, a deconstructor does the reverse and assigns
fields back to a set of variables.
A deconstruction method must be called Deconstruct and have one or more out
parameters, such as in the following class:
class Rectangle
{
 public readonly float Width, Height;

 public Rectangle (float width, float height)
 {
 Width = width;
 Height = height;
 }

 public void Deconstruct (out float width, out float height)
 {
 width = Width;
 height = Height;
 }
}
The following special syntax calls the deconstructor:
var rect = new Rectangle (3, 4);
(float width, float height) = rect; // Deconstruction
Console.WriteLine (width + " " + height); // 3 4
The second line is the deconstructing call. It creates two local variables and
then calls the Deconstruct method. Our deconstructing call is equivalent to the
following:
float width, height;
rect.Deconstruct (out width, out height);
Or:
rect.Deconstruct (out var width, out var height);
Deconstructing calls allow implicit typing, so we could shorten our call to this:
(var width, var height) = rect;
Or simply this:
var (width, height) = rect;
102 | Chapter 3: Creating Types in C#
You can use C#’s discard symbol (_) if you’re uninterested in
one or more variables:
var (_, height) = rect;
This better indicates your intention than declaring a variable
that you never use.
If the variables into which you’re deconstructing are already defined, omit the types
altogether:
float width, height;
(width, height) = rect;
This is called a deconstructing assignment. You can use a deconstructing assignment
to simplify your class’s constructor:
public Rectangle (float width, float height) =>
 (Width, Height) = (width, height);
You can offer the caller a range of deconstruction options by overloading the
Deconstruct method.
The Deconstruct method can be an extension method (see
“Extension Methods” on page 202). This is a useful trick if you
want to deconstruct types that you did not author.
From C# 10, you can mix and match existing and new variables when
deconstructing:
double x1 = 0;
(x1, double y2) = rect;
Object Initializers
To simplify object initialization, any accessible fields or properties of an object can
be set via an object initializer directly after construction. For example, consider the
following class:
public class Bunny
{
 public string Name;
 public bool LikesCarrots;
 public bool LikesHumans;
 public Bunny () {}
 public Bunny (string n) { Name = n; }
}
Using object initializers, you can instantiate Bunny objects as follows:
// Note parameterless constructors can omit empty parentheses
Bunny b1 = new Bunny { Name="Bo", LikesCarrots=true, LikesHumans=false };
Bunny b2 = new Bunny ("Bo") { LikesCarrots=true, LikesHumans=false };
Classes | 103
Creating
Types in C#
The code to construct b1 and b2 is precisely equivalent to the following:
Bunny temp1 = new Bunny(); // temp1 is a compiler-generated name
temp1.Name = "Bo";
temp1.LikesCarrots = true;
temp1.LikesHumans = false;
Bunny b1 = temp1;
Bunny temp2 = new Bunny ("Bo");
temp2.LikesCarrots = true;
temp2.LikesHumans = false;
Bunny b2 = temp2;
The temporary variables are to ensure that if an exception is thrown during initiali‐
zation, you can’t end up with a half-initialized object.
Object Initializers Versus Optional Parameters
Instead of using object initializers, we could make Bunny’s constructor accept
optional parameters:
public Bunny (string name,
 bool likesCarrots = false,
 bool likesHumans = false)
{
 Name = name;
 LikesCarrots = likesCarrots;
 LikesHumans = likesHumans;
}
This would allow us to construct a Bunny as follows:
Bunny b1 = new Bunny (name: "Bo",
 likesCarrots: true);
Historically, this approach could be advantageous in that it allowed us to make
Bunny’s fields (or properties, which we’ll explain shortly) read-only. Making fields
or properties read-only is good practice when there’s no valid reason for them
to change throughout the life of the object. However, as we’ll see soon in our
discussion on properties, the init modifier that was introduced in C# 9 lets us
achieve this goal with object initializers.
Optional parameters have two drawbacks. The first is that while their use in
constructors allows for read-only types, they don’t (easily) allow for nondestruc‐
tive mutation. (We’ll cover nondestructive mutation—and the solution to this
problem—in “Records” on page 211.)
The second drawback of optional parameters is that when used in public libraries,
they hinder backward compatibility. This is because the act of adding an optional
parameter at a later date breaks the assembly’s binary compatibility with existing
consumers. (This is particularly important when a library is published on NuGet:
the problem becomes intractable when a consumer references packages A and B, if
A and B each depend on incompatible versions of L.)
104 | Chapter 3: Creating Types in C#
The difficulty is that each optional parameter value is baked into the calling site. In
other words, C# translates our constructor call into this:
Bunny b1 = new Bunny ("Bo", true, false);
This is problematic if we instantiate the Bunny class from another assembly and
later modify Bunny by adding another optional parameter—such as likesCats.
Unless the referencing assembly is also recompiled, it will continue to call the
(now nonexistent) constructor with three parameters and fail at runtime. (A subtler
problem is that if we changed the value of one of the optional parameters, callers
in other assemblies would continue to use the old optional value until they were
recompiled.)
The this Reference
The this reference refers to the instance itself. In the following example, the Marry
method uses this to set the partner’s mate field:
public class Panda
{
 public Panda Mate;
 public void Marry (Panda partner)
 {
 Mate = partner;
 partner.Mate = this;
 }
}
The this reference also disambiguates a local variable or parameter from a field; for
example:
public class Test
{
 string name;
 public Test (string name) { this.name = name; }
}
The this reference is valid only within nonstatic members of a class or struct.
Properties
Properties look like fields from the outside, but internally they contain logic, like
methods do. For example, you can’t tell by looking at the following code whether
CurrentPrice is a field or a property:
Stock msft = new Stock();
msft.CurrentPrice = 30;
msft.CurrentPrice -= 3;
Console.WriteLine (msft.CurrentPrice);
A property is declared like a field but with a get/set block added. Here’s how to
implement CurrentPrice as a property:
Classes | 105
Creating
Types in C#
public class Stock
{
 decimal currentPrice; // The private "backing" field
 public decimal CurrentPrice // The public property
 {
 get { return currentPrice; }
 set { currentPrice = value; }
 }
}
get and set denote property accessors. The get accessor runs when the property
is read. It must return a value of the property’s type. The set accessor runs when
the property is assigned. It has an implicit parameter named value of the property’s
type that you typically assign to a private field (in this case, currentPrice).
Although properties are accessed in the same way as fields, they differ in that they
give the implementer complete control over getting and setting its value. This con‐
trol enables the implementer to choose whatever internal representation is needed
without exposing the internal details to the user of the property. In this example, the
set method could throw an exception if value was outside a valid range of values.
Throughout this book, we use public fields extensively to keep
the examples free of distraction. In a real application, you
would typically favor public properties over public fields in
order to promote encapsulation.
Properties allow the following modifiers:
Static modifier static
Access modifiers public internal private protected
Inheritance modifiers new virtual abstract override sealed
Unmanaged code modifiers unsafe extern
Read-only and calculated properties
A property is read-only if it specifies only a get accessor, and it is write-only if it
specifies only a set accessor. Write-only properties are rarely used.
A property typically has a dedicated backing field to store the underlying data.
However, a property can also be computed from other data:
decimal currentPrice, sharesOwned;
public decimal Worth
{
 get { return currentPrice * sharesOwned; }
}
106 | Chapter 3: Creating Types in C#
Expression-bodied properties
You can declare a read-only property, such as the one in the preceding example,
more tersely as an expression-bodied property. A fat arrow replaces all the braces and
the get and return keywords:
public decimal Worth => currentPrice * sharesOwned;
With a little extra syntax, set accessors can also be expression-bodied:
public decimal Worth
{
 get => currentPrice * sharesOwned;
 set => sharesOwned = value / currentPrice;
}
Automatic properties
The most common implementation for a property is a getter and/or setter that sim‐
ply reads and writes to a private field of the same type as the property. An automatic
property declaration instructs the compiler to provide this implementation. We can
improve the first example in this section by declaring CurrentPrice as an automatic
property:
public class Stock
{
 ...
 public decimal CurrentPrice { get; set; }
}
The compiler automatically generates a private backing field of a compilergenerated name that cannot be referred to. The set accessor can be marked private
or protected if you want to expose the property as read-only to other types.
Automatic properties were introduced in C# 3.0.
Property initializers
You can add a property initializer to automatic properties, just as with fields:
public decimal CurrentPrice { get; set; } = 123;
This gives CurrentPrice an initial value of 123. Properties with an initializer can be
read-only:
public int Maximum { get; } = 999;
Just as with read-only fields, read-only automatic properties can also be assigned in
the type’s constructor. This is useful in creating immutable (read-only) types.
get and set accessibility
The get and set accessors can have different access levels. The typical use case for
this is to have a public property with an internal or private access modifier on
the setter:
Classes | 107
Creating
Types in C#
public class Foo
{
 private decimal x;
 public decimal X
 {
 get { return x; }
 private set { x = Math.Round (value, 2); }
 }
}
Notice that you declare the property itself with the more permissive access level
(public, in this case) and add the modifier to the accessor you want to be less
accessible.
Init-only setters
From C# 9, you can declare a property accessor with init instead of set:
public class Note
{
 public int Pitch { get; init; } = 20; // “Init-only” property
 public int Duration { get; init; } = 100; // “Init-only” property
}
These init-only properties act like read-only properties, except that they can also be
set via an object initializer:
var note = new Note { Pitch = 50 };
After that, the property cannot be altered:
note.Pitch = 200; // Error – init-only setter!
Init-only properties cannot even be set from inside their class, except via their
property initializer, the constructor, or another init-only accessor.
The alternative to init-only properties is to have read-only properties that you
populate via a constructor:
public class Note
{
 public int Pitch { get; }
 public int Duration { get; }
 public Note (int pitch = 20, int duration = 100)
 {
 Pitch = pitch; Duration = duration;
 }
}
Should the class be part of a public library, this approach makes versioning difficult,
in that adding an optional parameter to the constructor at a later date breaks binary
compatibility with consumers (whereas adding a new init-only property breaks
nothing).
108 | Chapter 3: Creating Types in C#
Init-only properties have another significant advantage, which
is that they allow for nondestructive mutation when used in
conjunction with records (see “Records” on page 211).
As with ordinary set accessors, init-only accessors can provide an implementation:
public class Note
{
 readonly int _pitch;
 public int Pitch { get => _pitch; init => _pitch = value; }
 ...
Notice that the _pitch field is read-only: init-only setters are permitted to modify
readonly fields in their own class. (Without this feature, _pitch would need to be
writable, and the class would fail at being internally immutable.)
Changing a property’s accessor from init to set (or vice
versa) is a binary breaking change: anyone that references your
assembly will need to recompile their assembly.
This should not be an issue when creating wholly immutable
types, in that your type will never require properties with a
(writable) set accessor.
CLR property implementation
C# property accessors internally compile to methods called get_XXX and set_XXX:
public decimal get_CurrentPrice {...}
public void set_CurrentPrice (decimal value) {...}
An init accessor is processed like a set accessor, but with an extra flag encoded
into the set accessor’s “modreq” metadata (see “Init-only properties” on page 794).
Simple nonvirtual property accessors are inlined by the Just-in-Time (JIT) compiler,
eliminating any performance difference between accessing a property and a field.
Inlining is an optimization in which a method call is replaced with the body of that
method.
Indexers
Indexers provide a natural syntax for accessing elements in a class or struct that
encapsulate a list or dictionary of values. Indexers are similar to properties but are
accessed via an index argument rather than a property name. The string class has
an indexer that lets you access each of its char values via an int index:
string s = "hello";
Console.WriteLine (s[0]); // 'h'
Console.WriteLine (s[3]); // 'l'
The syntax for using indexers is like that for using arrays, except that the index
argument(s) can be of any type(s).
Classes | 109
Creating
Types in C#
Indexers have the same modifiers as properties (see “Properties” on page 105) and
can be called null-conditionally by inserting a question mark before the square
bracket (see “Null Operators” on page 74):
string s = null;
Console.WriteLine (s?[0]); // Writes nothing; no error.
Implementing an indexer
To write an indexer, define a property called this, specifying the arguments in
square brackets:
class Sentence
{
 string[] words = "The quick brown fox".Split();
 public string this [int wordNum] // indexer
 {
 get { return words [wordNum]; }
 set { words [wordNum] = value; }
 }
}
Here’s how we could use this indexer:
Sentence s = new Sentence();
Console.WriteLine (s[3]); // fox
s[3] = "kangaroo";
Console.WriteLine (s[3]); // kangaroo
A type can declare multiple indexers, each with parameters of different types. An
indexer can also take more than one parameter:
public string this [int arg1, string arg2]
{
 get { ... } set { ... }
}
If you omit the set accessor, an indexer becomes read-only, and you can use
expression-bodied syntax to shorten its definition:
public string this [int wordNum] => words [wordNum];
CLR indexer implementation
Indexers internally compile to methods called get_Item and set_Item, as follows:
public string get_Item (int wordNum) {...}
public void set_Item (int wordNum, string value) {...}
Using indices and ranges with indexers
You can support indices and ranges (see “Indices and ranges” on page 13) in your
own classes by defining an indexer with a parameter type of Index or Range.
110 | Chapter 3: Creating Types in C#
We could extend our previous example by adding the following indexers to the
Sentence class:
 public string this [Index index] => words [index];
 public string[] this [Range range] => words [range];
This then enables the following:
Sentence s = new Sentence();
Console.WriteLine (s [^1]); // fox
string[] firstTwoWords = s [..2]; // (The, quick)
Static Constructors
A static constructor executes once per type rather than once per instance. A type can
define only one static constructor, and it must be parameterless and have the same
name as the type:
class Test
{
 static Test() { Console.WriteLine ("Type Initialized"); }
}
The runtime automatically invokes a static constructor just prior to the type being
used. Two things trigger this:
• Instantiating the type
• Accessing a static member in the type
The only modifiers allowed by static constructors are unsafe and extern.
If a static constructor throws an unhandled exception (Chap‐
ter 4), that type becomes unusable for the life of the
application.
From C# 9, you can also define module initializers, which
execute once per assembly (when the assembly is first loaded).
To define a module initializer, write a static void method
and then apply the [ModuleInitializer] attribute to that
method:
[System.Runtime.CompilerServices.ModuleInitializer]
internal static void InitAssembly()
{
 ...
}
Static constructors and field initialization order
Static field initializers run just before the static constructor is called. If a type has
no static constructor, static field initializers will execute just prior to the type being
used—or anytime earlier at the whim of the runtime.
Classes | 111
Creating
Types in C#
Static field initializers run in the order in which the fields are declared. The follow‐
ing example illustrates this. X is initialized to 0, and Y is initialized to 3:
class Foo
{
 public static int X = Y; // 0
 public static int Y = 3; // 3
}
If we swap the two field initializers around, both fields are initialized to 3. The next
example prints 0 followed by 3 because the field initializer that instantiates a Foo
executes before X is initialized to 3:
Console.WriteLine (Foo.X); // 3
class Foo
{
 public static Foo Instance = new Foo();
 public static int X = 3;
 Foo() => Console.WriteLine (X); // 0
}
If we swap the two lines in boldface, the example prints 3 followed by 3.
Static Classes
A class marked static cannot be instantiated or subclassed, and must be composed
solely of static members. The System.Console and System.Math classes are good
examples of static classes.
Finalizers
Finalizers are class-only methods that execute before the garbage collector reclaims
the memory for an unreferenced object. The syntax for a finalizer is the name of the
class prefixed with the ~ symbol:
class Class1
{
 ~Class1()
 {
 ...
 }
}
This is actually C# syntax for overriding Object’s Finalize method, and the com‐
piler expands it into the following method declaration:
protected override void Finalize()
{
 ...
 base.Finalize();
}
We discuss garbage collection and finalizers fully in Chapter 12.
112 | Chapter 3: Creating Types in C#
Finalizers allow the following modifier:
Unmanaged code modifier unsafe
You can write single-statement finalizers using expression-bodied syntax:
~Class1() => Console.WriteLine ("Finalizing");
Partial Types and Methods
Partial types allow a type definition to be split—typically across multiple files. A
common scenario is for a partial class to be autogenerated from some other source
(such as a Visual Studio template or designer), and for that class to be augmented
with additional hand-authored methods:
// PaymentFormGen.cs - auto-generated
partial class PaymentForm { ... }
// PaymentForm.cs - hand-authored
partial class PaymentForm { ... }
Each participant must have the partial declaration; the following is illegal:
partial class PaymentForm {}
class PaymentForm {}
Participants cannot have conflicting members. A constructor with the same param‐
eters, for instance, cannot be repeated. Partial types are resolved entirely by the
compiler, which means that each participant must be available at compile time and
must reside in the same assembly.
You can specify a base class on one or more partial class declarations, as long
as the base class, if specified, is the same. In addition, each participant can inde‐
pendently specify interfaces to implement. We cover base classes and interfaces in
“Inheritance” on page 115 and “Interfaces” on page 134.
The compiler makes no guarantees with regard to field initialization order between
partial type declarations.
Partial methods
A partial type can contain partial methods. These let an autogenerated partial type
provide customizable hooks for manual authoring; for example:
partial class PaymentForm // In auto-generated file
{
 ...
 partial void ValidatePayment (decimal amount);
}
partial class PaymentForm // In hand-authored file
{
 ...
Classes | 113
Creating
Types in C#
 partial void ValidatePayment (decimal amount)
 {
 if (amount > 100)
 ...
 }
}
A partial method consists of two parts: a definition and an implementation. The
definition is typically written by a code generator, and the implementation is typi‐
cally manually authored. If an implementation is not provided, the definition of the
partial method is compiled away (as is the code that calls it). This allows autogener‐
ated code to be liberal in providing hooks without having to worry about bloat.
Partial methods must be void and are implicitly private. They cannot include out
parameters.
Extended partial methods
Extended partial methods (from C# 9) are designed for the reverse code generation
scenario, where a programmer defines hooks that a code generator implements. An
example of where this might occur is with source generators, a Roslyn feature that
lets you feed the compiler an assembly that automatically generates portions of your
code.
A partial method declaration is extended if it begins with an accessibility modifier:
public partial class Test
{
 public partial void M1(); // Extended partial method
 private partial void M2(); // Extended partial method
}
The presence of the accessibility modifier doesn’t just affect accessibility: it tells the
compiler to treat the declaration differently.
Extended partial methods must have implementations; they do not melt away
if unimplemented. In this example, both M1 and M2 must have implementations
because they each specify accessibility modifiers (public and private).
Because they cannot melt away, extended partial methods can return any type and
can include out parameters:
public partial class Test
{
 public partial bool IsValid (string identifier);
 internal partial bool TryParse (string number, out int result);
}
The nameof operator
The nameof operator returns the name of any symbol (type, member, variable, and
so on) as a string:
114 | Chapter 3: Creating Types in C#
int count = 123;
string name = nameof (count); // name is "count"
Its advantage over simply specifying a string is that of static type checking. Tools
such as Visual Studio can understand the symbol reference, so if you rename the
symbol in question, all of its references will be renamed, too.
To specify the name of a type member such as a field or property, include the type as
well. This works with both static and instance members:
string name = nameof (StringBuilder.Length);
This evaluates to Length. To return StringBuilder.Length, you would do this:
nameof (StringBuilder) + "." + nameof (StringBuilder.Length);
Inheritance
A class can inherit from another class to extend or customize the original class.
Inheriting from a class lets you reuse the functionality in that class instead of
building it from scratch. A class can inherit from only a single class but can itself be
inherited by many classes, thus forming a class hierarchy. In this example, we begin
by defining a class called Asset:
public class Asset
{
 public string Name;
}
Next, we define classes called Stock and House, which will inherit from Asset.
Stock and House get everything an Asset has, plus any additional members that
they define:
public class Stock : Asset // inherits from Asset
{
 public long SharesOwned;
}
public class House : Asset // inherits from Asset
{
 public decimal Mortgage;
}
Here’s how we can use these classes:
Stock msft = new Stock { Name="MSFT",
 SharesOwned=1000 };
Console.WriteLine (msft.Name); // MSFT
Console.WriteLine (msft.SharesOwned); // 1000
House mansion = new House { Name="Mansion",
 Mortgage=250000 };
Inheritance | 115
Creating
Types in C#
Console.WriteLine (mansion.Name); // Mansion
Console.WriteLine (mansion.Mortgage); // 250000
The derived classes, Stock and House, inherit the Name field from the base class,
Asset.
A derived class is also called a subclass.
A base class is also called a superclass.
Polymorphism
References are polymorphic. This means a variable of type x can refer to an object
that subclasses x. For instance, consider the following method:
public static void Display (Asset asset)
{
 System.Console.WriteLine (asset.Name);
}
This method can display both a Stock and a House because they are both Assets:
Stock msft = new Stock ... ;
House mansion = new House ... ;
Display (msft);
Display (mansion);
Polymorphism works on the basis that subclasses (Stock and House) have all the
features of their base class (Asset). The converse, however, is not true. If Display
was modified to accept a House, you could not pass in an Asset:
Display (new Asset()); // Compile-time error
public static void Display (House house) // Will not accept Asset
{
 System.Console.WriteLine (house.Mortgage);
}
Casting and Reference Conversions
An object reference can be:
• Implicitly upcast to a base class reference
• Explicitly downcast to a subclass reference
Upcasting and downcasting between compatible reference types performs reference
conversions: a new reference is (logically) created that points to the same object. An
upcast always succeeds; a downcast succeeds only if the object is suitably typed.
116 | Chapter 3: Creating Types in C#
Upcasting
An upcast operation creates a base class reference from a subclass reference:
Stock msft = new Stock();
Asset a = msft; // Upcast
After the upcast, variable a still references the same Stock object as variable msft.
The object being referenced is not itself altered or converted:
Console.WriteLine (a == msft); // True
Although a and msft refer to the identical object, a has a more restrictive view on
that object:
Console.WriteLine (a.Name); // OK
Console.WriteLine (a.SharesOwned); // Compile-time error
The last line generates a compile-time error because the variable a is of type Asset,
even though it refers to an object of type Stock. To get to its SharesOwned field, you
must downcast the Asset to a Stock.
Downcasting
A downcast operation creates a subclass reference from a base class reference:
Stock msft = new Stock();
Asset a = msft; // Upcast
Stock s = (Stock)a; // Downcast
Console.WriteLine (s.SharesOwned); // <No error>
Console.WriteLine (s == a); // True
Console.WriteLine (s == msft); // True
As with an upcast, only references are affected—not the underlying object. A down‐
cast requires an explicit cast because it can potentially fail at runtime:
House h = new House();
Asset a = h; // Upcast always succeeds
Stock s = (Stock)a; // Downcast fails: a is not a Stock
If a downcast fails, an InvalidCastException is thrown. This is an example of
runtime type checking (we elaborate on this concept in “Static and Runtime Type
Checking” on page 127).
The as operator
The as operator performs a downcast that evaluates to null (rather than throwing
an exception) if the downcast fails:
Asset a = new Asset();
Stock s = a as Stock; // s is null; no exception thrown
This is useful when you’re going to subsequently test whether the result is null:
if (s != null) Console.WriteLine (s.SharesOwned);
Inheritance | 117
Creating
Types in C#
Without such a test, a cast is advantageous, because if it fails,
a more helpful exception is thrown. We can illustrate by com‐
paring the following two lines of code:
long shares = ((Stock)a).SharesOwned; // Approach #1
long shares = (a as Stock).SharesOwned; // Approach #2
If a is not a Stock, the first line throws an InvalidCastExcep
tion, which is an accurate description of what went wrong.
The second line throws a NullReferenceException, which is
ambiguous. Was a not a Stock, or was a null?
Another way of looking at it is that with the cast operator,
you’re saying to the compiler, “I’m certain of a value’s type; if
I’m wrong, there’s a bug in my code, so throw an exception!”
Whereas with the as operator, you’re uncertain of its type and
want to branch according to the outcome at runtime.
The as operator cannot perform custom conversions (see “Operator Overloading” on
page 239), and it cannot do numeric conversions:
long x = 3 as long; // Compile-time error
The as and cast operators will also perform upcasts, although
this is not terribly useful because an implicit conversion will
do the job.
The is operator
The is operator tests whether a variable matches a pattern. C# supports several
kinds of patterns, the most important being a type pattern, where a type name
follows the is keyword.
In this context, the is operator tests whether a reference conversion would suc‐
ceed—in other words, whether an object derives from a specified class (or imple‐
ments an interface). It is often used to test before downcasting:
if (a is Stock)
 Console.WriteLine (((Stock)a).SharesOwned);
The is operator also evaluates to true if an unboxing conversion would succeed (see
“The object Type” on page 125). However, it does not consider custom or numeric
conversions.
The is operator works with many other patterns introduced
in recent versions of C#. For a full discussion, see “Patterns”
on page 222.
Introducing a pattern variable
You can introduce a variable while using the is operator:
if (a is Stock s)
 Console.WriteLine (s.SharesOwned);
118 | Chapter 3: Creating Types in C#
This is equivalent to the following:
Stock s;
if (a is Stock)
{
 s = (Stock) a;
 Console.WriteLine (s.SharesOwned);
}
The variable that you introduce is available for “immediate” consumption, so the
following is legal:
if (a is Stock s && s.SharesOwned > 100000)
 Console.WriteLine ("Wealthy");
And it remains in scope outside the is expression, allowing this:
if (a is Stock s && s.SharesOwned > 100000)
 Console.WriteLine ("Wealthy");
Else
 s = new Stock(); // s is in scope
Console.WriteLine (s.SharesOwned); // Still in scope
Virtual Function Members
A function marked as virtual can be overridden by subclasses wanting to provide
a specialized implementation. Methods, properties, indexers, and events can all be
declared virtual:
public class Asset
{
 public string Name;
 public virtual decimal Liability => 0; // Expression-bodied property
}
(Liability => 0 is a shortcut for { get { return 0; } }. For more details on
this syntax, see “Expression-bodied properties” on page 107.)
A subclass overrides a virtual method by applying the override modifier:
public class Stock : Asset
{
 public long SharesOwned;
}
public class House : Asset
{
 public decimal Mortgage;
 public override decimal Liability => Mortgage;
}
By default, the Liability of an Asset is 0. A Stock does not need to specialize this
behavior. However, the House specializes the Liability property to return the value
of the Mortgage:
Inheritance | 119
Creating
Types in C#
House mansion = new House { Name="McMansion", Mortgage=250000 };
Asset a = mansion;
Console.WriteLine (mansion.Liability); // 250000
Console.WriteLine (a.Liability); // 250000
The signatures, return types, and accessibility of the virtual and overridden methods
must be identical. An overridden method can call its base class implementation via
the base keyword (we cover this in “The base Keyword” on page 122).
Calling virtual methods from a constructor is potentially dan‐
gerous because authors of subclasses are unlikely to know,
when overriding the method, that they are working with
a partially initialized object. In other words, the overriding
method might end up accessing methods or properties that
rely on fields not yet initialized by the constructor.
Covariant return types
From C# 9, you can override a method (or property get accessor) such that it
returns a more derived (subclassed) type. For example:
public class Asset
{
 public string Name;
 public virtual Asset Clone() => new Asset { Name = Name };
}
public class House : Asset
{
 public decimal Mortgage;
 public override House Clone() => new House
 { Name = Name, Mortgage = Mortgage };
}
This is permitted because it does not break the contract that Clone must return an
Asset: it returns a House, which is an Asset (and more).
Prior to C# 9, you had to override methods with the identical return type:
public override Asset Clone() => new House { ... }
This still does the job, because the overridden Clone method instantiates a House
rather than an Asset. However, to treat the returned object as a House, you must
then perform a downcast:
House mansion1 = new House { Name="McMansion", Mortgage=250000 };
House mansion2 = (House) mansion1.Clone();
Abstract Classes and Abstract Members
A class declared as abstract can never be instantiated. Instead, only its concrete
subclasses can be instantiated.
120 | Chapter 3: Creating Types in C#
Abstract classes are able to define abstract members. Abstract members are like vir‐
tual members except that they don’t provide a default implementation. That imple‐
mentation must be provided by the subclass unless that subclass is also declared
abstract:
public abstract class Asset
{
 // Note empty implementation
 public abstract decimal NetValue { get; }
}
public class Stock : Asset
{
 public long SharesOwned;
 public decimal CurrentPrice;
 // Override like a virtual method.
 public override decimal NetValue => CurrentPrice * SharesOwned;
}
Hiding Inherited Members
A base class and a subclass can define identical members. For example:
public class A { public int Counter = 1; }
public class B : A { public int Counter = 2; }
The Counter field in class B is said to hide the Counter field in class A. Usually, this
happens by accident, when a member is added to the base type after an identical
member was added to the subtype. For this reason, the compiler generates a warn‐
ing and then resolves the ambiguity as follows:
• References to A (at compile time) bind to A.Counter.
• References to B (at compile time) bind to B.Counter.
Occasionally, you want to hide a member deliberately, in which case you can apply
the new modifier to the member in the subclass. The new modifier does nothing more
than suppress the compiler warning that would otherwise result:
public class A { public int Counter = 1; }
public class B : A { public new int Counter = 2; }
The new modifier communicates your intent to the compiler—and other program‐
mers—that the duplicate member is not an accident.
C# overloads the new keyword to have independent meanings
in different contexts. Specifically, the new operator is different
from the new member modifier.
Inheritance | 121
Creating
Types in C#
new versus override
Consider the following class hierarchy:
public class BaseClass
{
 public virtual void Foo() { Console.WriteLine ("BaseClass.Foo"); }
}
public class Overrider : BaseClass
{
 public override void Foo() { Console.WriteLine ("Overrider.Foo"); }
}
public class Hider : BaseClass
{
 public new void Foo() { Console.WriteLine ("Hider.Foo"); }
}
The differences in behavior between Overrider and Hider are demonstrated in the
following code:
Overrider over = new Overrider();
BaseClass b1 = over;
over.Foo(); // Overrider.Foo
b1.Foo(); // Overrider.Foo
Hider h = new Hider();
BaseClass b2 = h;
h.Foo(); // Hider.Foo
b2.Foo(); // BaseClass.Foo
Sealing Functions and Classes
An overridden function member can seal its implementation with the sealed key‐
word to prevent it from being overridden by further subclasses. In our earlier
virtual function member example, we could have sealed House’s implementation of
Liability, preventing a class that derives from House from overriding Liability,
as follows:
public sealed override decimal Liability { get { return Mortgage; } }
You can also apply the sealed modifier to the class itself, to prevent subclassing.
Sealing a class is more common than sealing a function member.
Although you can seal a function member against overriding, you can’t seal a
member against being hidden.
The base Keyword
The base keyword is similar to the this keyword. It serves two essential purposes:
• Accessing an overridden function member from the subclass
122 | Chapter 3: Creating Types in C#
• Calling a base-class constructor (see the next section)
In this example, House uses the base keyword to access Asset’s implementation of
Liability:
public class House : Asset
{
 ...
 public override decimal Liability => base.Liability + Mortgage;
}
With the base keyword, we access Asset’s Liability property nonvirtually. This
means that we will always access Asset’s version of this property—regardless of the
instance’s actual runtime type.
The same approach works if Liability is hidden rather than overridden. (You
can also access hidden members by casting to the base class before invoking the
function.)
Constructors and Inheritance
A subclass must declare its own constructors. The base class’s constructors are
accessible to the derived class but are never automatically inherited. For example, if
we define Baseclass and Subclass as follows:
public class Baseclass
{
 public int X;
 public Baseclass () { }
 public Baseclass (int x) { this.X = x; }
}
public class Subclass : Baseclass { }
the following is illegal:
Subclass s = new Subclass (123);
Subclass must hence “redefine” any constructors it wants to expose. In doing so,
however, it can call any of the base class’s constructors via the base keyword:
public class Subclass : Baseclass
{
 public Subclass (int x) : base (x) { }
}
The base keyword works rather like the this keyword except that it calls a con‐
structor in the base class.
Base-class constructors always execute first; this ensures that base initialization
occurs before specialized initialization.
Inheritance | 123
Creating
Types in C#
Implicit calling of the parameterless base-class constructor
If a constructor in a subclass omits the base keyword, the base type’s parameterless
constructor is implicitly called:
public class BaseClass
{
 public int X;
 public BaseClass() { X = 1; }
}
public class Subclass : BaseClass
{
 public Subclass() { Console.WriteLine (X); } // 1
}
If the base class has no accessible parameterless constructor, subclasses are forced to
use the base keyword in their constructors.
Constructor and field initialization order
When an object is instantiated, initialization takes place in the following order:
1. From subclass to base class:
a. Fields are initialized.
b. Arguments to base-class constructor calls are evaluated.
2. From base class to subclass:
a. Constructor bodies execute.
For example:
public class B
{
 int x = 1; // Executes 3rd
 public B (int x)
 {
 ... // Executes 4th
 }
}
public class D : B
{
 int y = 1; // Executes 1st
 public D (int x)
 : base (x + 1) // Executes 2nd
 {
 ... // Executes 5th
 }
}
124 | Chapter 3: Creating Types in C#
Overloading and Resolution
Inheritance has an interesting impact on method overloading. Consider the follow‐
ing two overloads:
static void Foo (Asset a) { }
static void Foo (House h) { }
When an overload is called, the most specific type has precedence:
House h = new House (...);
Foo(h); // Calls Foo(House)
The particular overload to call is determined statically (at compile time) rather than
at runtime. The following code calls Foo(Asset), even though the runtime type of a
is House:
Asset a = new House (...);
Foo(a); // Calls Foo(Asset)
If you cast Asset to dynamic (Chapter 4), the decision as to
which overload to call is deferred until runtime and is then
based on the object’s actual type:
Asset a = new House (...);
Foo ((dynamic)a); // Calls Foo(House)
The object Type
object (System.Object) is the ultimate base class for all types. Any type can be
upcast to object.
To illustrate how this is useful, consider a general-purpose stack. A stack is a data
structure based on the principle of LIFO—“last in, first out.” A stack has two
operations: push an object on the stack, and pop an object off the stack. Here is a
simple implementation that can hold up to 10 objects:
public class Stack
{
 int position;
 object[] data = new object[10];
 public void Push (object obj) { data[position++] = obj; }
 public object Pop() { return data[--position]; }
}
Because Stack works with the object type, we can Push and Pop instances of any
type to and from the Stack:
Stack stack = new Stack();
stack.Push ("sausage");
string s = (string) stack.Pop(); // Downcast, so explicit cast is needed
Console.WriteLine (s); // sausage
The object Type | 125
Creating
Types in C#
1 The reference type can also be System.ValueType or System.Enum (Chapter 6).
object is a reference type, by virtue of being a class. Despite this, value types, such
as int, can also be cast to and from object, and so be added to our stack. This
feature of C# is called type unification and is demonstrated here:
stack.Push (3);
int three = (int) stack.Pop();
When you cast between a value type and object, the CLR must perform some
special work to bridge the difference in semantics between value and reference
types. This process is called boxing and unboxing.
In “Generics” on page 145, we describe how to improve our
Stack class to better handle stacks with same-typed elements.
Boxing and Unboxing
Boxing is the act of converting a value-type instance to a reference-type instance.
The reference type can be either the object class or an interface (which we visit
later in the chapter).1
 In this example, we box an int into an object:
int x = 9;
object obj = x; // Box the int
Unboxing reverses the operation by casting the object back to the original value
type:
int y = (int)obj; // Unbox the int
Unboxing requires an explicit cast. The runtime checks that the stated value type
matches the actual object type, and throws an InvalidCastException if the check
fails. For instance, the following throws an exception because long does not exactly
match int:
object obj = 9; // 9 is inferred to be of type int
long x = (long) obj; // InvalidCastException
The following succeeds, however:
object obj = 9;
long x = (int) obj;
As does this:
object obj = 3.5; // 3.5 is inferred to be of type double
int x = (int) (double) obj; // x is now 3
In the last example, (double) performs an unboxing, and then (int) performs a
numeric conversion.
126 | Chapter 3: Creating Types in C#
Boxing conversions are crucial in providing a unified type
system. The system is not perfect, however: we’ll see in
“Generics” on page 145 that variance with arrays and generics
supports only reference conversions and not boxing conversions:
object[] a1 = new string[3]; // Legal
object[] a2 = new int[3]; // Error
Copying semantics of boxing and unboxing
Boxing copies the value-type instance into the new object, and unboxing copies the
contents of the object back into a value-type instance. In the following example,
changing the value of i doesn’t change its previously boxed copy:
int i = 3;
object boxed = i;
i = 5;
Console.WriteLine (boxed); // 3
Static and Runtime Type Checking
C# programs are type-checked both statically (at compile time) and at runtime (by
the CLR).
Static type checking enables the compiler to verify the correctness of your program
without running it. The following code will fail because the compiler enforces static
typing:
int x = "5";
Runtime type checking is performed by the CLR when you downcast via a reference
conversion or unboxing:
object y = "5";
int z = (int) y; // Runtime error, downcast failed
Runtime type checking is possible because each object on the heap internally stores
a little type token. You can retrieve this token by calling the GetType method of
object.
The GetType Method and typeof Operator
All types in C# are represented at runtime with an instance of System.Type. There
are two basic ways to get a System.Type object:
• Call GetType on the instance.
• Use the typeof operator on a type name.
GetType is evaluated at runtime; typeof is evaluated statically at compile time
(when generic type parameters are involved, it’s resolved by the JIT compiler).
The object Type | 127
Creating
Types in C#
System.Type has properties for such things as the type’s name, assembly, base type,
and so on:
Point p = new Point();
Console.WriteLine (p.GetType().Name); // Point
Console.WriteLine (typeof (Point).Name); // Point
Console.WriteLine (p.GetType() == typeof(Point)); // True
Console.WriteLine (p.X.GetType().Name); // Int32
Console.WriteLine (p.Y.GetType().FullName); // System.Int32
public class Point { public int X, Y; }
System.Type also has methods that act as a gateway to the runtime’s reflection
model, described in Chapter 18.
The ToString Method
The ToString method returns the default textual representation of a type instance.
This method is overridden by all built-in types. Here is an example of using the int
type’s ToString method:
int x = 1;
string s = x.ToString(); // s is "1"
You can override the ToString method on custom types as follows:
Panda p = new Panda { Name = "Petey" };
Console.WriteLine (p); // Petey
public class Panda
{
 public string Name;
 public override string ToString() => Name;
}
If you don’t override ToString, the method returns the type name.
When you call an overridden object member such as
ToString directly on a value type, boxing doesn’t occur. Box‐
ing then occurs only if you cast:
int x = 1;
string s1 = x.ToString(); // Calling on nonboxed value
object box = x;
string s2 = box.ToString(); // Calling on boxed value
Object Member Listing
Here are all the members of object:
public class Object
{
 public Object();
 public extern Type GetType();
128 | Chapter 3: Creating Types in C#
 public virtual bool Equals (object obj);
 public static bool Equals (object objA, object objB);
 public static bool ReferenceEquals (object objA, object objB);
 public virtual int GetHashCode();
 public virtual string ToString();
 protected virtual void Finalize();
 protected extern object MemberwiseClone();
}
We describe the Equals, ReferenceEquals, and GetHashCode methods in “Equality
Comparison” on page 324.
Structs
A struct is similar to a class, with the following key differences:
• A struct is a value type, whereas a class is a reference type.
• A struct does not support inheritance (other than implicitly deriving from
object, or more precisely, System.ValueType).
A struct can have all of the members that a class can, except for a finalizer. And
because it cannot be subclassed, members cannot be marked as virtual, abstract, or
protected.
Prior to C# 10, structs were further prohibited from defining
fields initializers and parameterless constructors. Although
this prohibition has now been relaxed—primarily for the ben‐
efit of record structs (see “Records” on page 211)—it’s worth
thinking carefully before defining these constructs, as they
can result in confusing behavior that we’ll describe in “Struct
Construction Semantics” on page 129.
A struct is appropriate when value-type semantics are desirable. Good examples of
structs are numeric types, where it is more natural for assignment to copy a value
rather than a reference. Because a struct is a value type, each instance does not
require instantiation of an object on the heap; this results in useful savings when
creating many instances of a type. For instance, creating an array of value type
elements requires only a single heap allocation.
Because structs are value types, an instance cannot be null. The default value for a
struct is an empty instance, with all fields empty (set to their default values).
Struct Construction Semantics
Unlike with classes, every field in a struct must be explicitly assigned in the con‐
structor (or field initializer). For example:
Structs | 129
Creating
Types in C#
struct Point
{
 int x, y;
 public Point (int x, int y) { this.x = x; this.y = y; } // OK
}
If we added the following constructor, the struct would not compile, because y
would remain unassigned:
 public Point (int x) { this.x = x; } // Not OK
The default constructor
In addition to any constructors that you define, a struct always has an implicit
parameterless constructor that performs a bitwise-zeroing of its fields (setting them
to their default values):
Point p = new Point(); // p.x and p.y will be 0
struct Point { int x, y; }
Even when you define a parameterless constructor of your own, the implicit param‐
eterless constructor still exists and can be accessed via the default keyword:
Point p1 = new Point(); // p1.x and p1.y will be 1
Point p2 = default; // p2.x and p2.y will be 0
struct Point
{
 int x = 1;
 int y;
 public Point() => y = 1;
}
In this example, we initialized x to 1 via a field initializer, and we initialized y to 1
via the parameterless constructor. And yet with the default keyword, we were still
able to create a Point that bypassed both initializations. The default constructor can
be accessed other ways, too, as the following example illustrates:
var points = new Point[10]; // Each point in the array will be (0,0)
var test = new Test(); // test.p will be (0,0)
class Test { Point p; }
Having what amounts to two parameterless constructors can
be a source of confusion and is arguably a good reason to
avoid defining field initializers and explicit parameterless con‐
structors in structs.
A good strategy with structs is to design them such that their default value is a
valid state, thereby making initialization redundant. For example, rather than this:
struct WebOptions { public string Protocol { get; set; } = "https"; }
consider the following:
130 | Chapter 3: Creating Types in C#
struct WebOptions
{
 string protocol;
 public string Protocol { get => protocol ?? "https";
 set => protocol = value; }
}
Read-Only Structs and Functions
You can apply the readonly modifier to a struct to enforce that all fields are
readonly; this aids in declaring intent as well as affording the compiler more
optimization freedom:
readonly struct Point
{
 public readonly int X, Y; // X and Y must be readonly
}
If you need to apply readonly at a more granular level, you can apply the readonly
modifier (from C# 8) to a struct’s functions. This ensures that if the function
attempts to modify any field, a compile-time error is generated:
struct Point
{
 public int X, Y;
 public readonly void ResetX() => X = 0; // Error!
}
If a readonly function calls a non-readonly function, the compiler generates a
warning (and defensively copies the struct to avoid the possibility of a mutation).
Ref Structs
Ref structs were introduced in C# 7.2 as a niche feature pri‐
marily for the benefit of the Span<T> and ReadOnlySpan<T>
structs that we describe in Chapter 23 (and the highly opti‐
mized Utf8JsonReader that we describe in Chapter 11). These
structs help with a micro-optimization technique that aims to
reduce memory allocations.
Unlike reference types, whose instances always live on the heap, value types live
in-place (wherever the variable was declared). If a value type appears as a parameter
or local variable, it will reside on the stack:
void SomeMethod()
{
 Point p; // p will reside on the stack
}
struct Point { public int X, Y; }
Structs | 131
Creating
Types in C#
But if a value type appears as a field in a class, it will reside on the heap:
class MyClass
{
 Point p; // Lives on heap, because MyClass instances live on the heap
}
Similarly, arrays of structs live on the heap, and boxing a struct sends it to the heap.
Adding the ref modifier to a struct’s declaration ensures that it can only ever reside
on the stack. Attempting to use a ref struct in such a way that it could reside on the
heap generates a compile-time error:
var points = new Point [100]; // Error: will not compile!
ref struct Point { public int X, Y; }
class MyClass { Point P; } // Error: will not compile!
Ref structs were introduced mainly for the benefit of the Span<T> and ReadOnly
Span<T> structs. Because Span<T> and ReadOnlySpan<T> instances can exist only on
the stack, it’s possible for them to safely wrap stack-allocated memory.
Ref structs cannot partake in any C# feature that directly or indirectly introduces
the possibility of existing on the heap. This includes a number of advanced C#
features that we describe in Chapter 4, namely lambda expressions, iterators, and
asynchronous functions (because, behind the scenes, these features all create hidden
classes with fields). Also, ref structs cannot appear inside non-ref structs, and they
cannot implement interfaces (because this could result in boxing).
Access Modifiers
To promote encapsulation, a type or type member can limit its accessibility to other
types and other assemblies by adding one of five access modifiers to the declaration:
public
Fully accessible. This is the implicit accessibility for members of an enum or
interface.
internal
Accessible only within the containing assembly or friend assemblies. This is the
default accessibility for non-nested types.
private
Accessible only within the containing type. This is the default accessibility for
members of a class or struct.
protected
Accessible only within the containing type or subclasses.
protected internal
The union of protected and internal accessibility. A member that is
protected internal is accessible in two ways.
132 | Chapter 3: Creating Types in C#
private protected (from C# 7.2)
The intersection of protected and internal accessibility. A member that is
private protected is accessible only within the containing type, or subclasses
that reside in the same assembly (making it less accessible than protected or
internal alone).
Examples
Class2 is accessible from outside its assembly; Class1 is not:
class Class1 {} // Class1 is internal (default)
public class Class2 {}
ClassB exposes field x to other types in the same assembly; ClassA does not:
class ClassA { int x; } // x is private (default)
class ClassB { internal int x; }
Functions within Subclass can call Bar but not Foo:
class BaseClass
{
 void Foo() {} // Foo is private (default)
 protected void Bar() {}
}
class Subclass : BaseClass
{
 void Test1() { Foo(); } // Error - cannot access Foo
 void Test2() { Bar(); } // OK
}
Friend Assemblies
You can expose internal members to other friend assemblies by adding
the System.Runtime.CompilerServices.InternalsVisibleTo assembly attribute,
specifying the name of the friend assembly as follows:
[assembly: InternalsVisibleTo ("Friend")]
If the friend assembly has a strong name (see Chapter 17), you must specify its full
160-byte public key:
[assembly: InternalsVisibleTo ("StrongFriend, PublicKey=0024f000048c...")]
You can extract the full public key from a strongly named assembly with a LINQ
query (we explain LINQ in detail in Chapter 8):
string key = string.Join ("",
 Assembly.GetExecutingAssembly().GetName().GetPublicKey()
 .Select (b => b.ToString ("x2")));
The companion sample in LINQPad invites you to browse to
an assembly and then copies the assembly’s full public key to
the clipboard.
Access Modifiers | 133
Creating
Types in C#
Accessibility Capping
A type caps the accessibility of its declared members. The most common example
of capping is when you have an internal type with public members. For example,
consider this:
class C { public void Foo() {} }
C’s (default) internal accessibility caps Foo’s accessibility, effectively making Foo
internal. A common reason Foo would be marked public is to make for easier
refactoring should C later be changed to public.
Restrictions on Access Modifiers
When overriding a base class function, accessibility must be identical on the over‐
ridden function; for example:
class BaseClass { protected virtual void Foo() {} }
class Subclass1 : BaseClass { protected override void Foo() {} } // OK
class Subclass2 : BaseClass { public override void Foo() {} } // Error
(An exception is when overriding a protected internal method in another assem‐
bly, in which case the override must simply be protected.)
The compiler prevents any inconsistent use of access modifiers. For example, a
subclass itself can be less accessible than a base class, but not more:
internal class A {}
public class B : A {} // Error
Interfaces
An interface is similar to a class, but only specifies behavior and does not hold state
(data). Consequently:
• An interface can define only functions and not fields.
• Interface members are implicitly abstract. (Although nonabstract functions are
permitted from C# 8, this is considered a special case, which we describe in
“Default Interface Members” on page 139.)
• A class (or struct) can implement multiple interfaces. In contrast, a class can
inherit from only a single class, and a struct cannot inherit at all (aside from
deriving from System.ValueType).
An interface declaration is like a class declaration, but it (typically) provides no
implementation for its members because its members are implicitly abstract. These
members will be implemented by the classes and structs that implement the inter‐
face. An interface can contain only functions, that is, methods, properties, events,
and indexers (which noncoincidentally are precisely the members of a class that can
be abstract).
134 | Chapter 3: Creating Types in C#
As defined in System.Collections, here is the definition of the IEnumerator
interface:
public interface IEnumerator
{
 bool MoveNext();
 object Current { get; }
 void Reset();
}
Interface members are always implicitly public and cannot declare an access modi‐
fier. Implementing an interface means providing a public implementation for all of
its members:
internal class Countdown : IEnumerator
{
 int count = 11;
 public bool MoveNext() => count-- > 0;
 public object Current => count;
 public void Reset() { throw new NotSupportedException(); }
}
You can implicitly cast an object to any interface that it implements:
IEnumerator e = new Countdown();
while (e.MoveNext())
 Console.Write (e.Current); // 109876543210
Even though Countdown is an internal class, its members that
implement IEnumerator can be called publicly by casting an
instance of Countdown to IEnumerator. For instance, if a pub‐
lic type in the same assembly defined a method as follows:
public static class Util
{
 public static object GetCountDown() => new CountDown();
}
a caller from another assembly could do this:
IEnumerator e = (IEnumerator) Util.GetCountDown();
e.MoveNext();
If IEnumerator were itself defined as internal, this wouldn’t
be possible.
Extending an Interface
Interfaces can derive from other interfaces; for instance:
public interface IUndoable { void Undo(); }
public interface IRedoable : IUndoable { void Redo(); }
IRedoable “inherits” all the members of IUndoable. In other words, types that
implement IRedoable must also implement the members of IUndoable.
Interfaces | 135
Creating
Types in C#
Explicit Interface Implementation
Implementing multiple interfaces can sometimes result in a collision between
member signatures. You can resolve such collisions by explicitly implementing an
interface member. Consider the following example:
interface I1 { void Foo(); }
interface I2 { int Foo(); }
public class Widget : I1, I2
{
 public void Foo()
 {
 Console.WriteLine ("Widget's implementation of I1.Foo");
 }
 int I2.Foo()
 {
 Console.WriteLine ("Widget's implementation of I2.Foo");
 return 42;
 }
}
Because I1 and I2 have conflicting Foo signatures, Widget explicitly implements I2’s
Foo method. This lets the two methods coexist in one class. The only way to call an
explicitly implemented member is to cast to its interface:
Widget w = new Widget();
w.Foo(); // Widget's implementation of I1.Foo
((I1)w).Foo(); // Widget's implementation of I1.Foo
((I2)w).Foo(); // Widget's implementation of I2.Foo
Another reason to explicitly implement interface members is to hide members that
are highly specialized and distracting to a type’s normal use case. For example, a
type that implements ISerializable would typically want to avoid flaunting its
ISerializable members unless explicitly cast to that interface.
Implementing Interface Members Virtually
An implicitly implemented interface member is, by default, sealed. It must be
marked virtual or abstract in the base class in order to be overridden:
public interface IUndoable { void Undo(); }
public class TextBox : IUndoable
{
 public virtual void Undo() => Console.WriteLine ("TextBox.Undo");
}
public class RichTextBox : TextBox
{
 public override void Undo() => Console.WriteLine ("RichTextBox.Undo");
}
136 | Chapter 3: Creating Types in C#
Calling the interface member through either the base class or the interface calls the
subclass’s implementation:
RichTextBox r = new RichTextBox();
r.Undo(); // RichTextBox.Undo
((IUndoable)r).Undo(); // RichTextBox.Undo
((TextBox)r).Undo(); // RichTextBox.Undo
An explicitly implemented interface member cannot be marked virtual, nor can it
be overridden in the usual manner. It can, however, be reimplemented.
Reimplementing an Interface in a Subclass
A subclass can reimplement any interface member already implemented by a base
class. Reimplementation hijacks a member implementation (when called through
the interface) and works whether or not the member is virtual in the base class. It
also works whether a member is implemented implicitly or explicitly—although it
works best in the latter case, as we will demonstrate.
In the following example, TextBox implements IUndoable.Undo explicitly, and so
it cannot be marked as virtual. To “override” it, RichTextBox must reimplement
IUndoable’s Undo method:
public interface IUndoable { void Undo(); }
public class TextBox : IUndoable
{
 void IUndoable.Undo() => Console.WriteLine ("TextBox.Undo");
}
public class RichTextBox : TextBox, IUndoable
{
 public void Undo() => Console.WriteLine ("RichTextBox.Undo");
}
Calling the reimplemented member through the interface calls the subclass’s
implementation:
RichTextBox r = new RichTextBox();
r.Undo(); // RichTextBox.Undo Case 1
((IUndoable)r).Undo(); // RichTextBox.Undo Case 2
Assuming the same RichTextBox definition, suppose that TextBox implemented
Undo implicitly:
public class TextBox : IUndoable
{
 public void Undo() => Console.WriteLine ("TextBox.Undo");
}
This would give us another way to call Undo, which would “break” the system, as
shown in Case 3:
RichTextBox r = new RichTextBox();
r.Undo(); // RichTextBox.Undo Case 1
Interfaces | 137
Creating
Types in C#
((IUndoable)r).Undo(); // RichTextBox.Undo Case 2
((TextBox)r).Undo(); // TextBox.Undo Case 3
Case 3 demonstrates that reimplementation hijacking is effective only when a mem‐
ber is called through the interface and not through the base class. This is usually
undesirable in that it can create inconsistent semantics. This makes reimplementa‐
tion most appropriate as a strategy for overriding explicitly implemented interface
members.
Alternatives to interface reimplementation
Even with explicit member implementation, interface reimplementation is problem‐
atic for a couple of reasons:
• The subclass has no way to call the base class method.
• The base class author might not anticipate that a method would be reimple‐
mented and might not allow for the potential consequences.
Reimplementation can be a good last resort when subclassing hasn’t been anticipa‐
ted. A better option, however, is to design a base class such that reimplementation
will never be required. There are two ways to achieve this:
• When implicitly implementing a member, mark it virtual if appropriate.
• When explicitly implementing a member, use the following pattern if you
anticipate that subclasses might need to override any logic:
public class TextBox : IUndoable
{
 void IUndoable.Undo() => Undo(); // Calls method below
 protected virtual void Undo() => Console.WriteLine ("TextBox.Undo");
}
public class RichTextBox : TextBox
{
 protected override void Undo() => Console.WriteLine("RichTextBox.Undo");
}
If you don’t anticipate any subclassing, you can mark the class as sealed to preempt
interface reimplementation.
Interfaces and Boxing
Converting a struct to an interface causes boxing. Calling an implicitly implemented
member on a struct does not cause boxing:
interface I { void Foo(); }
struct S : I { public void Foo() {} }
...
S s = new S();
s.Foo(); // No boxing.
138 | Chapter 3: Creating Types in C#
I i = s; // Box occurs when casting to interface.
i.Foo();
Default Interface Members
From C# 8, you can add a default implementation to an interface member, making it
optional to implement:
interface ILogger
{
 void Log (string text) => Console.WriteLine (text);
}
This is advantageous if you want to add a member to an interface defined in a
popular library without breaking (potentially thousands of) implementations.
Default implementations are always explicit, so if a class implementing ILogger fails
to define a Log method, the only way to call it is through the interface:
class Logger : ILogger { }
...
((ILogger)new Logger()).Log ("message");
This prevents a problem of multiple implementation inheritance: if the same default
member is added to two interfaces that a class implements, there is never an
ambiguity as to which member is called.
Interfaces can also now define static members (including fields), which can be
accessed from code inside default implementations:
interface ILogger
{
 void Log (string text) =>
 Console.WriteLine (Prefix + text);
 static string Prefix = "";
}
Because interface members are implicitly public, you can also access static members
from the outside:
ILogger.Prefix = "File log: ";
You can restrict this by adding an accessibility modifier to the static interface
member (such as private, protected, or internal).
Instance fields are (still) prohibited. This is in line with the principle of interfaces,
which is to define behavior, not state.
Interfaces | 139
Creating
Types in C#
Writing a Class Versus an Interface
As a guideline:
• Use classes and subclasses for types that naturally share an implementation.
• Use interfaces for types that have independent implementations.
Consider the following classes:
abstract class Animal {}
abstract class Bird : Animal {}
abstract class Insect : Animal {}
abstract class FlyingCreature : Animal {}
abstract class Carnivore : Animal {}
// Concrete classes:
class Ostrich : Bird {}
class Eagle : Bird, FlyingCreature, Carnivore {} // Illegal
class Bee : Insect, FlyingCreature {} // Illegal
class Flea : Insect, Carnivore {} // Illegal
The Eagle, Bee, and Flea classes do not compile because inheriting from multiple
classes is prohibited. To resolve this, we must convert some of the types to inter‐
faces. The question then arises, which types? Following our general rule, we could
say that insects share an implementation, and birds share an implementation, so
they remain classes. In contrast, flying creatures have independent mechanisms for
flying, and carnivores have independent strategies for eating animals, so we would
convert FlyingCreature and Carnivore to interfaces:
interface IFlyingCreature {}
interface ICarnivore {}
In a typical scenario, Bird and Insect might correspond to a Windows control and
a web control; FlyingCreature and Carnivore might correspond to IPrintable and
IUndoable.
Enums
An enum is a special value type that lets you specify a group of named numeric
constants. For example:
public enum BorderSide { Left, Right, Top, Bottom }
We can use this enum type as follows:
BorderSide topSide = BorderSide.Top;
bool isTop = (topSide == BorderSide.Top); // true
Each enum member has an underlying integral value. These are by default:
• Underlying values are of type int.
140 | Chapter 3: Creating Types in C#
• The constants 0, 1, 2... are automatically assigned in the declaration order of the
enum members.
You can specify an alternative integral type, as follows:
public enum BorderSide : byte { Left, Right, Top, Bottom }
You can also specify an explicit underlying value for each enum member:
public enum BorderSide : byte { Left=1, Right=2, Top=10, Bottom=11 }
The compiler also lets you explicitly assign some of the enum
members. The unassigned enum members keep incrementing
from the last explicit value. The preceding example is equiva‐
lent to the following:
public enum BorderSide : byte
 { Left=1, Right, Top=10, Bottom }
Enum Conversions
You can convert an enum instance to and from its underlying integral value with an
explicit cast:
int i = (int) BorderSide.Left;
BorderSide side = (BorderSide) i;
bool leftOrRight = (int) side <= 2;
You can also explicitly cast one enum type to another. Suppose that Horizontal
Alignment is defined as follows:
public enum HorizontalAlignment
{
 Left = BorderSide.Left,
 Right = BorderSide.Right,
 Center
}
A translation between the enum types uses the underlying integral values:
HorizontalAlignment h = (HorizontalAlignment) BorderSide.Right;
// same as:
HorizontalAlignment h = (HorizontalAlignment) (int) BorderSide.Right;
The numeric literal 0 is treated specially by the compiler in an enum expression and
does not require an explicit cast:
BorderSide b = 0; // No cast required
if (b == 0) ...
There are two reasons for the special treatment of 0:
• The first member of an enum is often used as the “default” value.
• For combined enum types, 0 means “no flags.”
Enums | 141
Creating
Types in C#
Flags Enums
You can combine enum members. To prevent ambiguities, members of a combina‐
ble enum require explicitly assigned values, typically in powers of two:
[Flags]
enum BorderSides { None=0, Left=1, Right=2, Top=4, Bottom=8 }
or:
enum BorderSides { None=0, Left=1, Right=1<<1, Top=1<<2, Bottom=1<<3 }
To work with combined enum values, you use bitwise operators such as | and &.
These operate on the underlying integral values:
BorderSides leftRight = BorderSides.Left | BorderSides.Right;
if ((leftRight & BorderSides.Left) != 0)
 Console.WriteLine ("Includes Left"); // Includes Left
string formatted = leftRight.ToString(); // "Left, Right"
BorderSides s = BorderSides.Left;
s |= BorderSides.Right;
Console.WriteLine (s == leftRight); // True
s ^= BorderSides.Right; // Toggles BorderSides.Right
Console.WriteLine (s); // Left
By convention, the Flags attribute should always be applied to an enum type
when its members are combinable. If you declare such an enum without the Flags
attribute, you can still combine members, but calling ToString on an enum instance
will emit a number rather than a series of names.
By convention, a combinable enum type is given a plural rather than singular name.
For convenience, you can include combination members within an enum declara‐
tion itself:
[Flags]
enum BorderSides
{
 None=0,
 Left=1, Right=1<<1, Top=1<<2, Bottom=1<<3,
 LeftRight = Left | Right,
 TopBottom = Top | Bottom,
 All = LeftRight | TopBottom
}
Enum Operators
The operators that work with enums are:
= == != < > <= >= + - ^ & | ˜
+= -= ++ -- sizeof
142 | Chapter 3: Creating Types in C#
The bitwise, arithmetic, and comparison operators return the result of processing
the underlying integral values. Addition is permitted between an enum and an
integral type, but not between two enums.
Type-Safety Issues
Consider the following enum:
public enum BorderSide { Left, Right, Top, Bottom }
Because an enum can be cast to and from its underlying integral type, the actual
value it can have might fall outside the bounds of a legal enum member:
BorderSide b = (BorderSide) 12345;
Console.WriteLine (b); // 12345
The bitwise and arithmetic operators can produce similarly invalid values:
BorderSide b = BorderSide.Bottom;
b++; // No errors
An invalid BorderSide would break the following code:
void Draw (BorderSide side)
{
 if (side == BorderSide.Left) {...}
 else if (side == BorderSide.Right) {...}
 else if (side == BorderSide.Top) {...}
 else {...} // Assume BorderSide.Bottom
}
One solution is to add another else clause:
 ...
 else if (side == BorderSide.Bottom) ...
 else throw new ArgumentException ("Invalid BorderSide: " + side, "side");
Another workaround is to explicitly check an enum value for validity. The static
Enum.IsDefined method does this job:
BorderSide side = (BorderSide) 12345;
Console.WriteLine (Enum.IsDefined (typeof (BorderSide), side)); // False
Unfortunately, Enum.IsDefined does not work for flagged enums. However, the
following helper method (a trick dependent on the behavior of Enum.ToString())
returns true if a given flagged enum is valid:
for (int i = 0; i <= 16; i++)
{
 BorderSides side = (BorderSides)i;
 Console.WriteLine (IsFlagDefined (side) + " " + side);
}
bool IsFlagDefined (Enum e)
{
 decimal d;
 return !decimal.TryParse(e.ToString(), out d);
Enums | 143
Creating
Types in C#
}
[Flags]
public enum BorderSides { Left=1, Right=2, Top=4, Bottom=8 }
Nested Types
A nested type is declared within the scope of another type:
public class TopLevel
{
 public class Nested { } // Nested class
 public enum Color { Red, Blue, Tan } // Nested enum
}
A nested type has the following features:
• It can access the enclosing type’s private members and everything else the
enclosing type can access.
• You can declare it with the full range of access modifiers rather than just
public and internal.
• The default accessibility for a nested type is private rather than internal.
• Accessing a nested type from outside the enclosing type requires qualification
with the enclosing type’s name (like when accessing static members).
For example, to access Color.Red from outside our TopLevel class, we’d need to do
this:
TopLevel.Color color = TopLevel.Color.Red;
All types (classes, structs, interfaces, delegates, and enums) can be nested within
either a class or a struct.
Here is an example of accessing a private member of a type from a nested type:
public class TopLevel
{
 static int x;
 class Nested
 {
 static void Foo() { Console.WriteLine (TopLevel.x); }
 }
}
Here is an example of applying the protected access modifier to a nested type:
public class TopLevel
{
 protected class Nested { }
}
public class SubTopLevel : TopLevel
{
144 | Chapter 3: Creating Types in C#
 static void Foo() { new TopLevel.Nested(); }
}
Here is an example of referring to a nested type from outside the enclosing type:
public class TopLevel
{
 public class Nested { }
}
class Test
{
 TopLevel.Nested n;
}
Nested types are used heavily by the compiler itself when it generates private classes
that capture state for constructs such as iterators and anonymous methods.
If the sole reason for using a nested type is to avoid cluttering
a namespace with too many types, consider using a nested
namespace instead. A nested type should be used because of
its stronger access control restrictions, or when the nested
class must access private members of the containing class.
Generics
C# has two separate mechanisms for writing code that is reusable across different
types: inheritance and generics. Whereas inheritance expresses reusability with a
base type, generics express reusability with a “template” that contains “placeholder”
types. Generics, when compared to inheritance, can increase type safety and reduce
casting and boxing.
C# generics and C++ templates are similar concepts, but they
work differently. We explain this difference in “C# Generics
Versus C++ Templates” on page 157.
Generic Types
A generic type declares type parameters—placeholder types to be filled in by the
consumer of the generic type, which supplies the type arguments. Here is a generic
type Stack<T>, designed to stack instances of type T. Stack<T> declares a single type
parameter T:
public class Stack<T>
{
 int position;
 T[] data = new T[100];
 public void Push (T obj) => data[position++] = obj;
 public T Pop() => data[--position];
}
Generics | 145
Creating
Types in C#
We can use Stack<T> as follows:
var stack = new Stack<int>();
stack.Push (5);
stack.Push (10);
int x = stack.Pop(); // x is 10
int y = stack.Pop(); // y is 5
Stack<int> fills in the type parameter T with the type argument int, implicitly cre‐
ating a type on the fly (the synthesis occurs at runtime). Attempting to push a string
onto our Stack<int> would, however, produce a compile-time error. Stack<int>
effectively has the following definition (substitutions appear in bold, with the class
name hashed out to avoid confusion):
public class ###
{
 int position;
 int[] data = new int[100];
 public void Push (int obj) => data[position++] = obj;
 public int Pop() => data[--position];
}
Technically, we say that Stack<T> is an open type, whereas Stack<int> is a closed
type. At runtime, all generic type instances are closed—with the placeholder types
filled in. This means that the following statement is illegal:
var stack = new Stack<T>(); // Illegal: What is T?
However, it’s legal if it’s within a class or method that itself defines T as a type
parameter:
public class Stack<T>
{
 ...
 public Stack<T> Clone()
 {
 Stack<T> clone = new Stack<T>(); // Legal
 ...
 }
}
Why Generics Exist
Generics exist to write code that is reusable across different types. Suppose that
we need a stack of integers, but we don’t have generic types. One solution would
be to hardcode a separate version of the class for every required element type
(e.g., IntStack, StringStack, etc.). Clearly, this would cause considerable code
duplication. Another solution would be to write a stack that is generalized by using
object as the element type:
public class ObjectStack
{
 int position;
 object[] data = new object[10];
146 | Chapter 3: Creating Types in C#
 public void Push (object obj) => data[position++] = obj;
 public object Pop() => data[--position];
}
An ObjectStack, however, wouldn’t work as well as a hardcoded IntStack for
specifically stacking integers. An ObjectStack would require boxing and downcast‐
ing that could not be checked at compile time:
// Suppose we just want to store integers here:
ObjectStack stack = new ObjectStack();
stack.Push ("s"); // Wrong type, but no error!
int i = (int)stack.Pop(); // Downcast - runtime error
What we need is both a general implementation of a stack that works for all element
types as well as a way to easily specialize that stack to a specific element type for
increased type safety and reduced casting and boxing. Generics give us precisely this
by allowing us to parameterize the element type. Stack<T> has the benefits of both
ObjectStack and IntStack. Like ObjectStack, Stack<T> is written once to work
generally across all types. Like IntStack, Stack<T> is specialized for a particular
type—the beauty is that this type is T, which we substitute on the fly.
ObjectStack is functionally equivalent to Stack<object>.
Generic Methods
A generic method declares type parameters within the signature of a method.
With generic methods, many fundamental algorithms can be implemented in a
general-purpose way. Here is a generic method that swaps the contents of two
variables of any type T:
static void Swap<T> (ref T a, ref T b)
{
 T temp = a;
 a = b;
 b = temp;
}
Swap<T> is called as follows:
int x = 5;
int y = 10;
Swap (ref x, ref y);
Generally, there is no need to supply type arguments to a generic method, because
the compiler can implicitly infer the type. If there is ambiguity, generic methods can
be called with type arguments as follows:
Swap<int> (ref x, ref y);
Generics | 147
Creating
Types in C#
Within a generic type, a method is not classed as generic unless it introduces type
parameters (with the angle bracket syntax). The Pop method in our generic stack
merely uses the type’s existing type parameter, T, and is not classed as a generic
method.
Methods and types are the only constructs that can introduce type parameters.
Properties, indexers, events, fields, constructors, operators, and so on cannot
declare type parameters, although they can partake in any type parameters already
declared by their enclosing type. In our generic stack example, for instance, we
could write an indexer that returns a generic item:
public T this [int index] => data [index];
Similarly, constructors can partake in existing type parameters but not introduce
them:
public Stack<T>() { } // Illegal
Declaring Type Parameters
Type parameters can be introduced in the declaration of classes, structs, interfaces,
delegates (covered in Chapter 4), and methods. Other constructs, such as proper‐
ties, cannot introduce a type parameter, but they can use one. For example, the
property Value uses T:
public struct Nullable<T>
{
 public T Value { get; }
}
A generic type or method can have multiple parameters:
class Dictionary<TKey, TValue> {...}
To instantiate:
Dictionary<int,string> myDict = new Dictionary<int,string>();
Or:
var myDict = new Dictionary<int,string>();
Generic type names and method names can be overloaded as long as the number
of type parameters is different. For example, the following three type names do not
conflict:
class A {}
class A<T> {}
class A<T1,T2> {}
By convention, generic types and methods with a single type
parameter typically name their parameter T, as long as the
intent of the parameter is clear. When using multiple type
parameters, each parameter is prefixed with T but has a more
descriptive name.
148 | Chapter 3: Creating Types in C#
typeof and Unbound Generic Types
Open generic types do not exist at runtime: they are closed as part of compilation.
However, it is possible for an unbound generic type to exist at runtime—purely as
a Type object. The only way to specify an unbound generic type in C# is via the
typeof operator:
class A<T> {}
class A<T1,T2> {}
...
Type a1 = typeof (A<>); // Unbound type (notice no type arguments).
Type a2 = typeof (A<,>); // Use commas to indicate multiple type args.
Open generic types are used in conjunction with the Reflection API (Chapter 18).
You can also use the typeof operator to specify a closed type:
Type a3 = typeof (A<int,int>);
Or, you can specify an open type (which is closed at runtime):
class B<T> { void X() { Type t = typeof (T); } }
The default Generic Value
You can use the default keyword to get the default value for a generic type parame‐
ter. The default value for a reference type is null, and the default value for a value
type is the result of bitwise-zeroing the value type’s fields:
static void Zap<T> (T[] array)
{
 for (int i = 0; i < array.Length; i++)
 array[i] = default(T);
}
From C# 7.1, you can omit the type argument for cases in which the compiler is able
to infer it. We could replace the last line of code with this:
 array[i] = default;
Generic Constraints
By default, you can substitute a type parameter with any type whatsoever. Con‐
straints can be applied to a type parameter to require more specific type arguments.
These are the possible constraints:
where T : base-class // Base-class constraint
where T : interface // Interface constraint
where T : class // Reference-type constraint
where T : class? // (see "Nullable Reference Types" in Chapter 1)
where T : struct // Value-type constraint (excludes Nullable types)
where T : unmanaged // Unmanaged constraint
where T : new() // Parameterless constructor constraint
where U : T // Naked type constraint
Generics | 149
Creating
Types in C#
where T : notnull // Non-nullable value type, or (from C# 8)
 // a non-nullable reference type
In the following example, GenericClass<T,U> requires T to derive from (or be
identical to) SomeClass and implement Interface1, and requires U to provide a
parameterless constructor:
class SomeClass {}
interface Interface1 {}
class GenericClass<T,U> where T : SomeClass, Interface1
 where U : new()
{...}
You can apply constraints wherever type parameters are defined, in both methods
and type definitions.
A base-class constraint specifies that the type parameter must subclass (or match)
a particular class; an interface constraint specifies that the type parameter must
implement that interface. These constraints allow instances of the type parameter
to be implicitly converted to that class or interface. For example, suppose that we
want to write a generic Max method, which returns the maximum of two values. We
can take advantage of the generic interface defined in the System namespace called
IComparable<T>:
public interface IComparable<T> // Simplified version of interface
{
 int CompareTo (T other);
}
CompareTo returns a positive number if this is greater than other. Using this
interface as a constraint, we can write a Max method as follows (to avoid distraction,
null checking is omitted):
static T Max <T> (T a, T b) where T : IComparable<T>
{
 return a.CompareTo (b) > 0 ? a : b;
}
The Max method can accept arguments of any type implementing IComparable<T>
(which includes most built-in types such as int and string):
int z = Max (5, 10); // 10
string last = Max ("ant", "zoo"); // zoo
The class constraint and struct constraint specify that T must be a reference type
or (non-nullable) value type. A great example of the struct constraint is the Sys
tem.Nullable<T> struct (we discuss this class in depth in “Nullable Value Types” on
page 194):
struct Nullable<T> where T : struct {...}
150 | Chapter 3: Creating Types in C#
The unmanaged constraint (introduced in C# 7.3) is a stronger version of a struct
constraint: T must be a simple value type or a struct that is (recursively) free of any
reference types.
The parameterless constructor constraint requires T to have a public parameterless
constructor. If this constraint is defined, you can call new() on T:
static void Initialize<T> (T[] array) where T : new()
{
 for (int i = 0; i < array.Length; i++)
 array[i] = new T();
}
The naked type constraint requires one type parameter to derive from (or match)
another type parameter. In this example, the method FilteredStack returns
another Stack, containing only the subset of elements where the type parameter
U is of the type parameter T:
class Stack<T>
{
 Stack<U> FilteredStack<U>() where U : T {...}
}
Subclassing Generic Types
A generic class can be subclassed just like a nongeneric class. The subclass can leave
the base class’s type parameters open, as in the following example:
class Stack<T> {...}
class SpecialStack<T> : Stack<T> {...}
Or, the subclass can close the generic type parameters with a concrete type:
class IntStack : Stack<int> {...}
A subtype can also introduce fresh type arguments:
class List<T> {...}
class KeyedList<T,TKey> : List<T> {...}
Technically, all type arguments on a subtype are fresh: you
could say that a subtype closes and then reopens the base
type arguments. This means that a subclass can give new (and
potentially more meaningful) names to the type arguments
that it reopens:
class List<T> {...}
class KeyedList<TElement,TKey> : List<TElement> {...}
Self-Referencing Generic Declarations
A type can name itself as the concrete type when closing a type argument:
public interface IEquatable<T> { bool Equals (T obj); }
public class Balloon : IEquatable<Balloon>
Generics | 151
Creating
Types in C#